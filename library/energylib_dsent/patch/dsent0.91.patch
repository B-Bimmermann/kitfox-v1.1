diff -Nur dsent0.91/DSENT.cc ../dsent0.91/DSENT.cc
--- dsent0.91/DSENT.cc	2012-05-22 14:47:57.000000000 -0400
+++ ../dsent0.91/DSENT.cc	2015-04-24 20:18:56.000000000 -0400
@@ -79,8 +79,8 @@
         Log::allocate(option_parser->get("LogFilename"));
 
         // Init the config file
-        Config::allocate(option_parser->get("ConfigFilename"));
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig::allocate(option_parser->get("ConfigFilename"));
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
 
         // Overwrite the existing options
         dsent_config->readString(option_parser->get("OverwriteString"));
@@ -123,7 +123,7 @@
 
     void DSENT::buildModel()
     {
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
 
         // Create the model specified
         const String& model_name = dsent_config->get("ModelName");
@@ -178,7 +178,7 @@
 
     void DSENT::processQuery()
     {
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
         vector<String> queries = dsent_config->get("QueryString").split(" ;\r\n");
 
         if(ms_is_verbose_)
@@ -275,7 +275,7 @@
         ms_model_ = NULL;
 
         // Release the config file
-        Config::release();
+        DSENTConfig::release();
 
         // Release the log file
         Log::release();
@@ -285,7 +285,7 @@
 
     void DSENT::performTimingOpt()
     {
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
 
         // Get the frequency it is optimizing to
         double freq = dsent_config->get("Frequency").toDouble();
@@ -343,7 +343,7 @@
 
     void DSENT::reportTiming()
     {
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
 
         // Get all the starting net names
         const vector<String>& start_net_names = dsent_config->get("ReportTiming->StartNetNames").split("[,]");
@@ -365,7 +365,7 @@
 
     void DSENT::processEvaluate()
     {
-        Config* dsent_config = Config::getSingleton();
+        DSENTConfig* dsent_config = DSENTConfig::getSingleton();
 
         // Return if EvaluatString is empty or not exists
         if(!dsent_config->keyExist("EvaluateString")) return;
@@ -409,9 +409,9 @@
         {
             return m_var_.get(var_name_);
         }
-        else if(Config::getSingleton()->keyExist(var_name_))
+        else if(DSENTConfig::getSingleton()->keyExist(var_name_))
         {
-            return Config::getSingleton()->get(var_name_);
+            return DSENTConfig::getSingleton()->get(var_name_);
         }
         else
         {
diff -Nur dsent0.91/DSENT.h ../dsent0.91/DSENT.h
--- dsent0.91/DSENT.h	2012-05-20 22:40:36.000000000 -0400
+++ ../dsent0.91/DSENT.h	2015-04-24 20:18:56.000000000 -0400
@@ -3,7 +3,7 @@
 
 // For DSENT operations
 #include "libutil/OptionParser.h"
-#include "libutil/Calculator.h"
+#include "libutil/libutilCalculator.h"
 #include "util/CommonType.h"
 #include "util/Config.h"
 #include "util/Result.h"
diff -Nur dsent0.91/Makefile ../dsent0.91/Makefile
--- dsent0.91/Makefile	2012-06-26 15:42:01.000000000 -0400
+++ ../dsent0.91/Makefile	2015-04-24 20:18:56.000000000 -0400
@@ -48,8 +48,12 @@
 %/created:
 	mkdir -p $(dir $@)
 	touch $@
+    
+lib: DSENT.o $(LIB_UTIL) $(OBJS)
+	ar qcv libdsent.a $(OBJS)
+	ranlib libdsent.a
 
 .phony: clean
 clean:
-	$(RM) -rf main.o DSENT.o $(OBJS) $(TARGET)
+	$(RM) -rf main.o DSENT.o $(OBJS) $(TARGET) libdsent.a
 	$(MAKE) -C $(CURDIR)/libutil clean
diff -Nur dsent0.91/libutil/Assert.h ../dsent0.91/libutil/Assert.h
--- dsent0.91/libutil/Assert.h	2011-05-17 18:55:30.000000000 -0400
+++ ../dsent0.91/libutil/Assert.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,22 +0,0 @@
-#ifndef __ASSERT_H__
-#define __ASSERT_H__
-
-#include "String.h"
-#include "Exception.h"
-
-#ifdef NDEBUG
-#define ASSERT(test_value_,exception_msg_)
-#else
-#define ASSERT(test_value_,msg_) \
-    do \
-    { \
-        if(!(test_value_)) \
-        { \
-            const LibUtil::String& exception_msg = LibUtil::String::format("\nAt %s:%d\n", __FILE__, __LINE__) + (String)(msg_); \
-            throw LibUtil::Exception(exception_msg); \
-        } \
-    } while(0);
-#endif
-
-#endif // __ASSERT_H__
-
diff -Nur dsent0.91/libutil/Calculator.cc ../dsent0.91/libutil/Calculator.cc
--- dsent0.91/libutil/Calculator.cc	2012-05-20 22:40:57.000000000 -0400
+++ ../dsent0.91/libutil/Calculator.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,239 +0,0 @@
-#include "Calculator.h"
-
-#include <cctype>
-#include <iostream>
-
-namespace LibUtil
-{
-    using std::cout;
-    using std::endl;
-    using std::scientific;
-
-    Calculator::Calculator()
-    {
-        m_reserved_chars_ = "+-*/;=()\\";
-    }
-
-    Calculator::~Calculator()
-    {}
-
-    void Calculator::reset()
-    {
-        m_var_.clear();
-        return;
-    }
-
-    void Calculator::evaluateString(const String& str_)
-    {
-        istringstream ist(str_);
-        while(ist)
-        {
-            getToken(ist);
-            if(m_curr_token_ == END) break;
-            if(m_curr_token_ == SEP) continue;
-            if((m_curr_token_ == NAME) && (m_value_string_ == "print"))
-            {
-                getToken(ist);
-
-                if(m_curr_token_ == STRING)
-                {
-                    String print_str = m_value_string_;
-
-                    getToken(ist);
-                    if(m_curr_token_ == SEP)
-                    {
-                        cout << print_str << endl;
-                    }
-                    else
-                    {
-                        double v = expr(ist, false);
-                        cout << scientific << print_str << v << endl;
-                    }
-                }
-                else
-                {
-                    double v = expr(ist, false);
-                    cout << scientific << v << endl;
-                }
-            }
-            else
-            {
-                expr(ist, false);
-            }
-        }
-        return;
-    }
-
-    Calculator::Token Calculator::getToken(istringstream& ist_)
-    {
-        char ch;
-        do
-        {
-            ist_.get(ch);
-            if(!ist_)
-            {
-                m_curr_token_ = END;
-                return m_curr_token_;
-            }
-        }
-        while(ch != '\n' && isspace(ch));
-
-        switch(ch)
-        {
-            case '\n':
-                m_curr_token_ = END;
-                return m_curr_token_;
-            case ';':
-                m_curr_token_ = SEP;
-                return m_curr_token_;
-            case '*':
-            case '/':
-            case '+':
-            case '-':
-            case '(':
-            case ')':
-            case '=':
-                m_curr_token_ = Token(ch);
-                return m_curr_token_;
-            case '0': case '1': case '2': case '3': case '4':
-            case '5': case '6': case '7': case '8': case '9':
-            case '.':
-                ist_.putback(ch);
-                ist_ >> m_value_number_;
-                m_curr_token_ = NUMBER;
-                return m_curr_token_;
-            case '"':
-                ist_.get(ch);
-                m_value_string_ = "";
-                while(ist_ && ('"' != ch))
-                {
-                    m_value_string_ += String(1, ch);
-                    ist_.get(ch);
-                }
-                m_curr_token_ = STRING;
-                return m_curr_token_;
-            case '$':
-                ist_.get(ch);
-                ASSERT((ch == '('), "[Error] Bad token: '(' expected");
-                ist_.get(ch);
-                m_value_string_ = "";
-                while(ist_ && (!isspace(ch)) && (')' != ch))
-                {
-                    m_value_string_ += String(1, ch);
-                    ist_.get(ch);
-                }
-                m_curr_token_ = NAME2;
-                return m_curr_token_;
-            default:
-                if(isalpha(ch))
-                {
-                    m_value_string_ = ch;
-                    ist_.get(ch);
-                    while(ist_ && (isalnum(ch) || ('_' == ch)))
-                    {
-                        m_value_string_ += String(1, ch);
-                        ist_.get(ch);
-                    }
-                    ist_.putback(ch);
-                    m_curr_token_ = NAME;
-                    return m_curr_token_;
-                }
-                else
-                {
-                    String error_msg = "[Error] Bad token: '" + String(ch) + "'";
-                    throw Exception(error_msg);
-                }
-        }
-    }
-
-    double Calculator::prim(istringstream& ist_, bool is_get_)
-    {
-        if(is_get_)
-        {
-            getToken(ist_);
-        }
-
-        double v;
-        switch(m_curr_token_)
-        {
-            case NUMBER:
-                v = m_value_number_;
-                getToken(ist_);
-                return v;
-            case NAME:
-                if(getToken(ist_) == ASSIGN)
-                {
-                    String var_name = m_value_string_;
-                    v = expr(ist_, true);
-                    m_var_.set(var_name, v);
-                }
-                else
-                {
-                    v = m_var_.get(m_value_string_);
-                }
-                return v;
-            case NAME2:
-                v = getEnvVar(m_value_string_);
-                getToken(ist_);
-                return v;
-            case MINUS:
-                return -prim(ist_, true);
-            case LP:
-                v = expr(ist_, true);
-                ASSERT((m_curr_token_ == RP), "[Error] ')' expected");
-                getToken(ist_);
-                return v;
-            default:
-                ASSERT(0, "[Error] primary expected, get: '" + String(int(m_curr_token_)) + "'");
-        }
-    }
-
-    double Calculator::term(istringstream& ist_, bool is_get_)
-    {
-        double left = prim(ist_, is_get_);
-
-        while(1)
-        {
-            double d;
-            switch(m_curr_token_)
-            {
-                case MUL:
-                    left *= prim(ist_, true);
-                    break;
-                case DIV:
-                    d = prim(ist_, true);
-                    ASSERT(d, "[Error] divided by 0");
-                    left /= d;
-                    break;
-                default:
-                    return left;
-            }
-        }
-    }
-
-    double Calculator::expr(istringstream& ist_, bool is_get_)
-    {
-        double left = term(ist_, is_get_);
-
-        while(1)
-        {
-            switch(m_curr_token_)
-            {
-                case PLUS:
-                    left += term(ist_, true);
-                    break;
-                case MINUS:
-                    left -= term(ist_, true);
-                    break;
-                default:
-                    return left;
-            }
-        }
-    }
-
-    double Calculator::getEnvVar(const String& var_name_) const
-    {
-        return m_var_.get(var_name_);
-    }
-} // namespace LibUtil
-
diff -Nur dsent0.91/libutil/Calculator.h ../dsent0.91/libutil/Calculator.h
--- dsent0.91/libutil/Calculator.h	2012-05-20 22:40:57.000000000 -0400
+++ ../dsent0.91/libutil/Calculator.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,86 +0,0 @@
-#ifndef __LIBUTIL_CALCULATOR_H__
-#define __LIBUTIL_CALCULATOR_H__
-
-#include <sstream>
-
-#include "String.h"
-#include "Map.h"
-#include "Assert.h"
-
-namespace LibUtil
-{
-    using std::istringstream;
-
-    /*
-     *  program:
-     *      END                         // END is end-of-input
-     *      expr_list END
-     *
-     *  expr_list:
-     *      expression SEP expr_list    // SEP is semicolon
-     *      expression                  
-     *      print expression
-     *      print STRING
-     *      print STRING expression
-     *      print STRING expression SEP expr_list
-     *
-     *
-     *  expression:
-     *      expression + term
-     *      expression - term
-     *      term
-     *
-     *  term:
-     *      term / primary
-     *      term * primary
-     *      primary
-     *
-     *  primary:
-     *      NUMBER
-     *      NAME
-     *      NAME = expression
-     *      NAME string expression      // NAME is print
-     *      - primary
-     *      ( expression )
-     *
-     *  string:
-     *      
-     **/
-
-    class Calculator
-    {
-        protected:
-            enum Token
-            {
-                NAME, NAME2, NUMBER, STRING, END,
-                PLUS = '+', MINUS = '-', MUL = '*', DIV = '/',
-                SEP = ';', ASSIGN = '=', LP = '(', RP = ')'
-            };
-
-        public:
-            Calculator();
-            virtual ~Calculator();
-
-        public:
-            void reset();
-            void evaluateString(const String& str_);
-
-        protected:
-            Token getToken(istringstream& ist_);
-            double prim(istringstream& ist_, bool is_get_);
-            double term(istringstream& ist_, bool is_get_);
-            double expr(istringstream& ist_, bool is_get_);
-            virtual double getEnvVar(const String& var_name_) const;
-
-        protected:
-            String m_reserved_chars_;
-            Map<double> m_var_;
-
-            Token m_curr_token_;
-            double m_value_number_;
-            String m_value_string_;
-    }; // class Calculator
-} // namespace LibUtil
-
-#endif // __LIBUTIL_CALCULATOR_H__
-
diff -Nur dsent0.91/libutil/Config.cc ../dsent0.91/libutil/Config.cc
--- dsent0.91/libutil/Config.cc	2012-05-22 07:50:32.000000000 -0400
+++ ../dsent0.91/libutil/Config.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,144 +0,0 @@
-#include "Config.h"
-
-#include <fstream>
-
-#include "Assert.h"
-
-namespace LibUtil
-{
-    Config::Config(const String& delimiter_, const String& comment_, const String& sentry_)
-        : mDelimiter(delimiter_), mComment(comment_), mSentry(sentry_)
-    {}
-
-    Config::Config(const Config& config_)
-        : StringMap(config_)
-    {
-        mDelimiter = config_.mDelimiter;
-        mComment = config_.mComment;
-        mSentry = config_.mSentry;
-    }
-
-    Config::~Config()
-    {}
-
-    Config* Config::clone() const
-    {
-        return new Config(*this);
-    }
-
-    void Config::readFile(const String& filename_)
-    {
-        std::ifstream fin(filename_.c_str());
-
-        ASSERT(fin, "File not found: " + filename_);
-        fin >> (*this);
-        return;
-    }
-
-    void Config::readString(const String& str_)
-    {
-        String newString = str_;
-        newString.substitute(";", "\n");
-        std::istringstream iss(newString, std::istringstream::in);
-
-        iss >> (*this);
-    }
-
-    std::ostream& operator<<(std::ostream& ost_, const Config& config_)
-    {
-        Config::ConstIterator it;
-        for(it = config_.begin(); it != config_.end(); it++)
-        {
-            ost_ << it->first << " " << config_.mDelimiter << " ";
-            ost_ << it->second << std::endl;
-        }
-        return ost_;
-    }
-
-    std::istream& operator>>(std::istream& ist_, Config& config_)
-    {
-        // Set a Config from ist_
-        // Read in keys and values, keeping internal whitespace
-        typedef String::size_type pos;
-        const String& delim  = config_.mDelimiter;  // separator
-        const String& comm   = config_.mComment;    // comment
-        const String& sentry = config_.mSentry;     // end of file sentry
-        const pos skip = delim.length();        // length of separator
-
-        String nextline = "";  // might need to read ahead to see where value ends
-
-        while(ist_ || nextline.length() > 0)
-        {
-            // Read an entire line at a time
-            String line;
-            if(nextline.length() > 0)
-            {
-                line = nextline;  // we read ahead; use it now
-                nextline = "";
-            }
-            else
-            {
-                //std::getline(ist_, line);
-                safeGetline(ist_, line);
-            }
-
-            // Ignore comments and the spaces on both ends
-            line = line.substr(0, line.find(comm));
-            line.trim();
-
-            // Check for end of file sentry
-            if((sentry != "") && (line.find(sentry) != String::npos)) return ist_;
-
-            if(line.length() == 0)
-                continue;
-
-            // Parse the line if it contains a delimiter
-            pos delimPos = line.find(delim);
-            ASSERT((delimPos < String::npos), "Invalid config line: '" + line + "'");
-
-            // Extract the key
-            String key = line.substr(0, delimPos);
-            line.replace(0, delimPos+skip, "");
-
-            // See if value continues on the next line
-            // Stop at blank line, next line with a key, end of stream,
-            // or end of file sentry
-            bool terminate = false;
-            while(!terminate && ist_)
-            {
-                if(line.at(line.size() - 1) == '\\')
-                    line.erase(line.size() - 1);
-                else
-                    break;
-
-                //std::getline(ist_, nextline);
-                safeGetline(ist_, nextline);
-                terminate = true;
-
-                String nlcopy = nextline;
-                nlcopy.trim();
-                if(nlcopy == "") continue;
-
-                nextline = nextline.substr(0, nextline.find(comm));
-                //if(nextline.find(delim) != String::npos)
-                //    continue;
-                if((sentry != "") && (nextline.find(sentry) != String::npos))
-                    continue;
-
-                //nlcopy = nextline;
-                //nlcopy.trim();
-                //if(nlcopy != "") line += "\n";
-                line += nextline;
-                nextline = "";
-                terminate = false;
-            }
-
-            // Store key and value
-            key.trim();
-            line.trim();
-            config_.set(key, line);  // overwrites if key is repeated
-        }
-        return ist_;
-    }
-}
-
diff -Nur dsent0.91/libutil/Config.h ../dsent0.91/libutil/Config.h
--- dsent0.91/libutil/Config.h	2012-05-20 22:40:57.000000000 -0400
+++ ../dsent0.91/libutil/Config.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-#ifndef __LIBUTIL_CONFIG_H__
-#define __LIBUTIL_CONFIG_H__
-
-#include <iostream>
-
-#include "Map.h"
-
-namespace LibUtil
-{
-    class Config : public StringMap
-    {
-        public:
-            Config(const String& delimiter_ = "=", const String& comment_ = "#", const String& sentry_ = "End");
-            Config(const Config& config_);
-            virtual ~Config();
-
-        public:
-            // Make a copy of this instance
-            virtual Config* clone() const;
-            // Load the config from file
-            virtual void readFile(const String& filename_);
-            // Parse string and overwrite the Config instance if keys exist
-            virtual void readString(const String& str_);
-
-            // Write or read map using standard IO
-            friend std::ostream& operator<<(std::ostream& ost_, const Config& config_);
-            friend std::istream& operator>>(std::istream& ist_, Config& config_);
-
-        protected:
-            String mDelimiter;
-            String mComment;
-            String mSentry;
-    };
-}
-
-#endif // __LIBUTIL_CONFIG_H__
-
diff -Nur dsent0.91/libutil/Exception.cc ../dsent0.91/libutil/Exception.cc
--- dsent0.91/libutil/Exception.cc	2011-01-31 02:42:59.000000000 -0500
+++ ../dsent0.91/libutil/Exception.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-#include "Exception.h"
-
-namespace LibUtil
-{
-    Exception::Exception(const String& exception_msg_) throw()
-        : exception(), mExceptionMsg(exception_msg_)
-    {}
-
-    Exception::~Exception() throw()
-    {}
-
-    const char* Exception::what() const throw()
-    {
-        return mExceptionMsg.c_str();
-    }
-}
-
diff -Nur dsent0.91/libutil/Exception.h ../dsent0.91/libutil/Exception.h
--- dsent0.91/libutil/Exception.h	2011-01-31 02:42:59.000000000 -0500
+++ ../dsent0.91/libutil/Exception.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-#ifndef __EXCEPTION_H__
-#define __EXCEPTION_H__
-
-#include <exception>
-
-#include "String.h"
-
-namespace LibUtil
-{
-    using std::exception;
-
-    // Exception class handles the all exception messages in the program
-    class Exception : public exception
-    {
-        public:
-            // All constructors/destructors/functions in this class don't throw any events
-            Exception(const String& exception_msg_) throw();
-            ~Exception() throw();
-
-            // Derived from std::exception class that returns a null-terminated char string
-            const char* what() const throw();
-
-        private:
-            String mExceptionMsg;
-    };
-}
-
-#endif // __EXCEPTION_H__
-
diff -Nur dsent0.91/libutil/LibUtil.h ../dsent0.91/libutil/LibUtil.h
--- dsent0.91/libutil/LibUtil.h	2011-05-17 18:55:30.000000000 -0400
+++ ../dsent0.91/libutil/LibUtil.h	2015-04-24 20:18:56.000000000 -0400
@@ -3,12 +3,12 @@
 
 #include <vector>
 
-#include "String.h"
-#include "Exception.h"
-#include "Assert.h"
-#include "Map.h"
-#include "Log.h"
-#include "Config.h"
+#include "libutilString.h"
+#include "libutilException.h"
+#include "libutilAssert.h"
+#include "libutilMap.h"
+#include "libutilLog.h"
+#include "libutilConfig.h"
 #include "MathUtil.h"
 
 namespace LibUtil
diff -Nur dsent0.91/libutil/Log.cc ../dsent0.91/libutil/Log.cc
--- dsent0.91/libutil/Log.cc	2012-05-21 19:09:34.000000000 -0400
+++ ../dsent0.91/libutil/Log.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,86 +0,0 @@
-#include "Log.h"
-
-#include "Assert.h"
-
-namespace LibUtil
-{
-    using std::ostream;
-    using std::endl;
-
-    Log* Log::msSingleton = NULL;
-    const bool Log::msIsLog = LIBUTIL_IS_LOG;
-
-    void Log::allocate(const String& log_file_name_)
-    {
-        if(msIsLog)
-        {
-            // Allocate static Config instance
-            ASSERT(!msSingleton, "Log singleton is allocated");
-            msSingleton = new Log(log_file_name_);
-        }
-    }
-
-    void Log::release()
-    {
-        if(msIsLog)
-        {
-            ASSERT(msSingleton, "Log singleton is not allocated");
-            delete msSingleton;
-            msSingleton = NULL;
-        }
-        return;
-    }
-
-    void Log::print(const String& str_)
-    {
-        if(msIsLog)
-        {
-            ASSERT(msSingleton, "Log singleton is not allocated");
-            msSingleton->ofs << str_;
-        }
-        return;
-    }
-
-    void Log::print(ostream& stream_, const String& str_)
-    {
-        if(msIsLog)
-        {
-            ASSERT(msSingleton, "Log singleton is not allocated");
-            msSingleton->ofs << str_;
-        }
-        stream_ << str_;
-        return;
-    }
-
-    void Log::printLine(const String& str_)
-    {
-        if(msIsLog)
-        {
-            ASSERT(msSingleton, "Log singleton is not allocated");
-            msSingleton->ofs << str_ << endl;
-        }
-        return;
-    }
-
-    void Log::printLine(ostream& stream_, const String& str_)
-    {
-        if(msIsLog)
-        {
-            ASSERT(msSingleton, "Log singleton is not allocated");
-            msSingleton->ofs << str_ << endl;
-        }
-        stream_ << str_ << endl;
-        return;
-    }
-
-    Log::Log(const String& log_file_name_)
-    {
-        ofs.open(log_file_name_.c_str());
-    }
-
-    Log::~Log()
-    {
-        ofs.close();
-    }
-}
-
diff -Nur dsent0.91/libutil/Log.h ../dsent0.91/libutil/Log.h
--- dsent0.91/libutil/Log.h	2011-04-26 22:35:17.000000000 -0400
+++ ../dsent0.91/libutil/Log.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-#ifndef __LOG_H__
-#define __LOG_H__
-
-#include <cstdio>
-#include <iostream>
-#include <fstream>
-
-#include "String.h"
-
-#ifndef LIBUTIL_IS_LOG
-#define LIBUTIL_IS_LOG false
-#endif
-
-namespace LibUtil
-{
-    using std::cerr;
-
-    class Log
-    {
-        public:
-            static void allocate(const String& log_file_name_);
-            static void release();
-
-            static void print(const String& str_);
-            static void print(std::ostream& stream_, const String& str_);
-            static void printLine(const String& str_);
-            static void printLine(std::ostream& stream_, const String& str_);
-
-        protected:
-            static Log* msSingleton;
-            static const bool msIsLog;
-
-        protected:
-            Log(const String& log_file_name_);
-            ~Log();
-
-        protected:
-            std::ofstream ofs;
-    };
-}
-
-#endif // __LOG_H__
-
diff -Nur dsent0.91/libutil/Map.h ../dsent0.91/libutil/Map.h
--- dsent0.91/libutil/Map.h	2011-05-17 18:55:30.000000000 -0400
+++ ../dsent0.91/libutil/Map.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,242 +0,0 @@
-#ifndef __MAP_H__
-#define __MAP_H__
-
-#include <iostream>
-#include <map>
-
-#include "String.h"
-#include "Assert.h"
-
-namespace LibUtil
-{
-    using std::map;
-
-    template<class T> class Map
-    {
-        public:
-            typedef typename map<String, T>::iterator       Iterator;
-            typedef typename map<String, T>::const_iterator ConstIterator;
-            typedef typename map<String, T>::size_type      SizeType;
-
-        public:
-            Map();
-            virtual ~Map();
-
-        public:
-            // Return a new copy of this Map instance
-            Map* clone() const;
-            // Copy map_ to this instance
-            void copyFrom(const Map<T>* map_);
-            // Return the size of the map
-            SizeType size() const;
-            // Check if the map is empty
-            bool isEmpty() const;
-            // Check if the key exists
-            bool keyExist(const String& key_) const;
-            // Get the value_ corresponding to the key_
-            const T& get(const String& key_) const;
-            // Get the value_ corresponding to the key_ if the key_ exist, otherwise, the default_value_is returned
-            const T& getIfKeyExist(const String& key_, const T& default_value_ = T()) const;
-            // Add/Update a <key_, value_> entry
-            void set(const String& key_, const T& value_);
-            // Get iterator to the element
-            Iterator find(const String& key_);
-            ConstIterator find(const String& key_) const;
-            // Remove an entry corresponding to key_
-            void remove(const String& key_);
-            // Remove an entry at 'it' 
-            void remove(Iterator it);
-            // Remove all keys
-            void clear();
-            // Merge a map. Values with same key will be overwritten.
-            void merge(const Map<T>* map_);
-            // Returns a MapIterator referring to the first element in the map
-            Iterator begin();
-            ConstIterator begin() const;
-            // Returns a MapIterator referring to the past-the-end element in the map
-            Iterator end();
-            ConstIterator end() const;
-
-        protected:
-            Map(const Map& map_);
-
-        protected:
-            map<String, T> mMap;
-    };
-
-    template<class T> Map<T>::Map()
-    {}
-
-    template<class T> Map<T>::~Map()
-    {}
-
-    template<class T> Map<T>* Map<T>::clone() const
-    {
-        return new Map<T>(*this);
-    }
-
-    template<class T> void Map<T>::copyFrom(const Map<T>* map_)
-    {
-        // Remove all keys (it won't free the content if T is a pointer)
-        mMap.clear();
-
-        // Copy the contents
-        mMap = map_->mMap;
-    }
-
-    template<class T> typename Map<T>::SizeType Map<T>::size() const
-    {
-        return mMap.size();
-    }
-
-    template<class T> bool Map<T>::isEmpty() const
-    {
-        return (mMap.empty());
-    }
-
-    template<class T> bool Map<T>::keyExist(const String& key_) const
-    {
-        ConstIterator it = mMap.find(key_);
-        return (it != mMap.end());
-    }
-
-    template<class T> const T& Map<T>::get(const String& key_) const
-    {
-        ConstIterator it;
-
-        it = mMap.find(key_);
-        ASSERT((it != mMap.end()), "Key not found: " + key_);
-        return (it->second);
-    }
-
-    template<class T> const T& Map<T>::getIfKeyExist(const String& key_, const T& default_value_) const
-    {
-        if(keyExist(key_))
-        {
-            return get(key_);
-        }
-        else
-        {
-            return default_value_;
-        }
-    }
-
-    template<class T> void Map<T>::set(const String& key_, const T& value_)
-    {
-        mMap[key_] = value_;
-        return;
-    }
-
-    template<class T> typename Map<T>::Iterator Map<T>::find(const String& key_)
-    {
-        return mMap.find(key_);
-    }
-
-    template<class T> typename Map<T>::ConstIterator Map<T>::find(const String& key_) const
-    {
-        return mMap.find(key_);
-    }
-
-    template<class T> void Map<T>::remove(const String& key_)
-    {
-        mMap.erase(key_);
-        return;
-    }
-
-    template<class T> void Map<T>::remove(Iterator it)
-    {
-        mMap.erase(it);
-        return;
-    }
-
-    template<class T> void Map<T>::clear()
-    {
-        mMap.clear();
-        return;
-    }
-
-    template<class T> void Map<T>::merge(const Map<T>* map_)
-    {
-        ConstIterator it;
-        for(it = map_->begin(); it != map_->end(); it++)
-        {
-            const String& key = it->first;
-            const T& value = it->second;
-            set(key, value);
-        }
-        return;
-    }
-
-    template<class T> typename Map<T>::Iterator Map<T>::begin()
-    {
-        return mMap.begin();
-    }
-
-    template<class T> typename Map<T>::ConstIterator Map<T>::begin() const
-    {
-        return mMap.begin();
-    }
-
-    template<class T> typename Map<T>::Iterator Map<T>::end()
-    {
-        return mMap.end();
-    }
-
-    template<class T> typename Map<T>::ConstIterator Map<T>::end() const
-    {
-        return mMap.end();
-    }
-
-    inline std::ostream& operator<<(std::ostream& ost_, const Map<String>& map_)
-    {
-        Map<String>::ConstIterator it;
-        for(it = map_.begin(); it != map_.end(); it++)
-        {
-            ost_ << it->first << " = " << it->second << std::endl;
-        }
-        return ost_;
-    }
-
-    template<class T> Map<T>::Map(const Map<T>& map_)
-        : mMap(map_.mMap)
-    {}
-
-    typedef Map<String> StringMap;
-
-
-    // Handy function to delete all pointers in a map
-    template<class T> void clearPtrMap(Map<T*>* map_)
-    {
-        for(typename Map<T*>::Iterator it = map_->begin(); it != map_->end(); ++it)
-        {
-            T* temp_T = it->second;
-            delete temp_T;
-        }
-        map_->clear();
-        return;
-    }
-
-    // Handy function to delete all pointers in a map and the map itself
-    template<class T> void deletePtrMap(Map<T*>* map_)
-    {
-        clearPtrMap<T>(map_);
-        delete map_;
-        return;
-    }
-
-    // Handy function to clone all pointers in a map
-    template<class T> Map<T*>* clonePtrMap(const Map<T*>* map_)
-    {
-        Map<T*>* new_T_map = new Map<T*>;
-        for(typename Map<T*>::ConstIterator it = map_->begin(); it != map_->end(); ++it)
-        {
-            const String& temp_name = it->first;
-            const T* temp_T = it->second;
-            new_T_map->set(temp_name, temp_T->clone());
-        }
-        return new_T_map;
-    }
-}
-
-#endif // __MAP_H__
-
diff -Nur dsent0.91/libutil/MathUtil.h ../dsent0.91/libutil/MathUtil.h
--- dsent0.91/libutil/MathUtil.h	2011-05-17 18:55:30.000000000 -0400
+++ ../dsent0.91/libutil/MathUtil.h	2015-04-24 20:18:56.000000000 -0400
@@ -1,5 +1,5 @@
-#ifndef __MATH_H__
-#define __MATH_H__
+#ifndef __LIBUTIL_MATH_H__
+#define __LIBUTIL_MATH_H__
 
 #include <cmath>
 
diff -Nur dsent0.91/libutil/OptionParser.h ../dsent0.91/libutil/OptionParser.h
--- dsent0.91/libutil/OptionParser.h	2012-05-22 14:48:07.000000000 -0400
+++ ../dsent0.91/libutil/OptionParser.h	2015-04-24 20:18:56.000000000 -0400
@@ -3,7 +3,7 @@
 
 #include <vector>
 
-#include "Map.h"
+#include "libutilMap.h"
 
 namespace LibUtil
 {
diff -Nur dsent0.91/libutil/String.cc ../dsent0.91/libutil/String.cc
--- dsent0.91/libutil/String.cc	2012-05-22 07:50:32.000000000 -0400
+++ ../dsent0.91/libutil/String.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,347 +0,0 @@
-#include "String.h"
-
-#include <cstdarg>
-#include <cstdio>
-#include <iostream>
-#include <ios>
-
-namespace LibUtil
-{
-    const unsigned int String::msBufferSize = 4096;
-
-    String String::format(const String& format_, ...)
-    {
-        char buffer[msBufferSize];
-
-        va_list args;
-        va_start(args, format_);
-        vsnprintf(buffer, msBufferSize, format_.c_str(), args);
-        va_end(args);
-
-        return (String)(buffer);
-    }
-
-    String String::format(const String& format_, va_list args_)
-    {
-        char buffer[msBufferSize];
-
-        vsnprintf(buffer, msBufferSize, format_.c_str(), args_);
-
-        return (String)(buffer);
-    }
-
-    String::String()
-    {}
-
-    String::String(const string& str_)
-        : string(str_)
-    {}
-
-    String::String(const char* str_, size_t n_)
-        : string(str_, n_)
-    {}
-
-    String::String(const char* str_)
-        : string(str_)
-    {}
-
-    String::String(size_t n_, char c_)
-        : string(n_, c_)
-    {}
-
-    String::String(int value_)
-        : string(toString<int>(value_))
-    {}
-
-    String::String(unsigned int value_)
-        : string(toString<unsigned int>(value_))
-    {}
-
-    String::String(long value_)
-        : string(toString<long>(value_))
-    {}
-
-    String::String(unsigned long value_)
-        : string(toString<unsigned long>(value_))
-    {}
-
-    String::String(float value_)
-        : string(toString<float>(value_))
-    {}
-
-    String::String(double value_)
-        : string(toString<double>(value_))
-    {}
-
-    String::String(bool value_)
-        : string(toString<bool>(value_))
-    {}
-
-    String::~String()
-    {}
-
-    String& String::trim()
-    {
-        // Remove leading and trailing whitespace
-        static const char whitespace[] = " \n\t\v\r\f";
-        erase(0, find_first_not_of(whitespace));
-        erase(find_last_not_of(whitespace) + 1U);
-        return (*this);
-    }
-
-    String& String::substitute(const String& str1_, const String& str2_)
-    {
-        size_t str1Size = str1_.size();
-        size_t str2Size = str2_.size();
-
-        size_t pos;
-        pos = find(str1_);
-        while(pos != string::npos)
-        {
-            replace(pos, str1Size, str2_);
-            pos += str2Size;
-            pos = find(str1_, pos);
-        }
-        return (*this);
-    }
-
-    vector<String> String::split(const char* delimiters_) const
-    {
-        vector<String> result;
-
-        if(size() == 0)
-        {
-            return result;
-        }
-
-        size_t currPos, nextPos;
-        currPos = 0;
-        nextPos = find_first_of(delimiters_);
-        while(1)
-        {
-            if(nextPos == string::npos)
-            {
-                if(currPos != size())
-                {
-                    result.push_back(substr(currPos));
-                }
-                break;
-            }
-
-            if(nextPos != currPos)
-            {
-                result.push_back(substr(currPos, nextPos - currPos));
-            }
-            currPos = nextPos + 1;
-            nextPos = find_first_of(delimiters_, currPos);
-        }
-
-        return result;
-    }
-
-    vector<String> String::split(const String* delimiters_, unsigned int num_delimiters_) const
-    {
-        vector<String> result;
-
-        if(size() == 0)
-        {
-            return result;
-        }
-
-        if(num_delimiters_ == 1)
-        {
-            size_t currPos, nextPos;
-            currPos = 0;
-            nextPos = find(delimiters_[0]);
-            while(1)
-            {
-                if(nextPos == String::npos)
-                {
-                    result.push_back(substr(currPos));
-                    break;
-                }
-
-                if(nextPos != currPos)
-                {
-                    result.push_back(substr(currPos, nextPos - currPos));
-                }
-                currPos = nextPos + delimiters_[0].size();
-                nextPos = find(delimiters_[0], currPos);
-            }
-        }
-        else
-        {
-            // Currently the length of the delimiters are not checked
-            unsigned int delimiterLength = 0;
-            size_t currPos, nextPos;
-            currPos = 0;
-            nextPos = size();
-            for(unsigned int i = 0; i < num_delimiters_; ++i)
-            {
-                size_t tempPos = find(delimiters_[i], currPos);
-                if((tempPos != String::npos) && (tempPos < nextPos))
-                {
-                    nextPos = tempPos;
-                    delimiterLength = delimiters_[i].size();
-                }
-            }
-            while(1)
-            {
-                if((nextPos == String::npos) || (nextPos == size()))
-                {
-                    result.push_back(substr(currPos));
-                    break;
-                }
-
-                if(nextPos != currPos)
-                {
-                    result.push_back(substr(currPos, nextPos - currPos));
-                }
-                currPos = nextPos + delimiterLength;
-                nextPos = size();
-                delimiterLength = 0;
-                for(unsigned int i = 0; i < num_delimiters_; ++i)
-                {
-                    size_t tempPos = find(delimiters_[i], currPos);
-                    if((tempPos != String::npos) && (tempPos < nextPos))
-                    {
-                        nextPos = tempPos;
-                        delimiterLength = delimiters_[i].size();
-                    }
-                }
-            }
-        }
-        return result;
-    }
-
-    vector<String> String::splitByString(const String& delimiter_) const
-    {
-        return split(&delimiter_, 1);
-    }
-
-    bool String::contain(const String& str_) const
-    {
-        return (find(str_) != String::npos);
-    }
-
-    const char* String::toCString() const
-    {
-        return this->c_str();
-    }
-
-    int String::toInt() const
-    {
-        return fromString<int>(*this);
-    }
-
-    unsigned int String::toUInt() const
-    {
-        return fromString<unsigned int>(*this);
-    }
-
-    long String::toLong() const
-    {
-        return fromString<long>(*this);
-    }
-
-    unsigned long String::toULong() const
-    {
-        return fromString<unsigned long>(*this);
-    }
-
-    float String::toFloat() const
-    {
-        return fromString<float>(*this);
-    }
-
-    double String::toDouble() const
-    {
-        return fromString<double>(*this);
-    }
-
-    bool String::toBool() const
-    {
-        return fromString<bool>(*this);
-    }
-
-    String::operator const char*() const
-    {
-        return this->c_str();
-    }
-
-    String::operator int() const
-    {
-        return fromString<int>(*this);
-    }
-
-    String::operator unsigned int() const
-    {
-        return fromString<unsigned int>(*this);
-    }
-
-    String::operator long() const
-    {
-        return fromString<long>(*this);
-    }
-
-    String::operator unsigned long() const
-    {
-        return fromString<unsigned long>(*this);
-    }
-
-    String::operator float() const
-    {
-        return fromString<float>(*this);
-    }
-
-    String::operator double() const
-    {
-        return fromString<double>(*this);
-    }
-
-    String::operator bool() const
-    {
-        return fromString<bool>(*this);
-    }
-
-    String& String::operator=(char c_)
-    {
-        this->assign(1, c_);
-        return *this;
-    }
-
-    std::istream& safeGetline(std::istream& is_, String& str_)
-    {
-        str_.clear();
-
-        // The characters in the stream are read one-by-one using a std::streambuf.
-        // That is faster than reading them one-by-one using the std::istream.
-        // Code that uses streambuf this way must be guarded by a sentry object.
-        // The sentry object performs various tasks,
-        // such as thread synchronization and updating the stream state.
-
-        std::istream::sentry se(is_, true);
-        std::streambuf* sb = is_.rdbuf();
-
-        while(1)
-        {
-            int c = sb->sbumpc();
-            switch(c)
-            {
-                case '\r':
-                    c = sb->sgetc();
-                    if(c == '\n')
-                        sb->sbumpc();
-                    return is_;
-                case '\n':
-                    return is_;
-                case EOF:
-                    is_.setstate(std::ios_base::failbit|std::ios_base::eofbit);
-                    return is_;
-                default:
-                    str_ += String(1, (char)c);
-            }
-        }
-    }
-} // namespace LibUtil
-
diff -Nur dsent0.91/libutil/String.h ../dsent0.91/libutil/String.h
--- dsent0.91/libutil/String.h	2012-05-22 07:50:32.000000000 -0400
+++ ../dsent0.91/libutil/String.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,218 +0,0 @@
-#ifndef __STRING_H__
-#define __STRING_H__
-
-#include <string>
-#include <cstdarg>
-#include <vector>
-#include <sstream>
-#include <bitset>
-
-namespace LibUtil
-{
-    using std::string;
-    using std::vector;
-
-    class String : public string
-    {
-        public:
-            static String format(const String& format_, ...);
-            static String format(const String& format_, va_list args_);
-            template<class T> static String toString(const T& value_);
-            static String toBitString(unsigned int value_, unsigned int num_bits_);
-            template<class T> static T fromString(const String& str_);
-
-        private:
-            static const unsigned int msBufferSize;
-
-        public:
-            String();
-            String(const string& str_);
-            String(const char* str_, size_t n);
-            String(const char* str_);
-            String(size_t n, char c);
-            String(int value_);
-            String(unsigned int value_);
-            String(long value_);
-            String(unsigned long value_);
-            String(float value_);
-            String(double value_);
-            String(bool value_);
-            ~String();
-
-        public:
-            // Remove leading and trailing whitespace
-            String& trim();
-            // Substitute str1 with str2
-            String& substitute(const String& str1_, const String& str2_);
-            // Split the String into vector of Strings separated by delimiters_
-            vector<String> split(const char* delimiters_) const;
-            vector<String> split(const String* delimiters_, unsigned int num_delimiters_ = 1) const;
-            vector<String> splitByString(const String& delimiters_) const;
-
-            // Check if contains str
-            bool contain(const String& str_) const;
-
-        public:
-            // Convertions
-            const char* toCString() const;
-            int toInt() const;
-            unsigned int toUInt() const;
-            long toLong() const;
-            unsigned long toULong() const;
-            float toFloat() const;
-            double toDouble() const;
-            bool toBool() const;
-            operator const char*() const;
-            operator int() const;
-            operator unsigned int() const;
-            operator long() const;
-            operator unsigned long() const;
-            operator float() const;
-            operator double() const;
-            operator bool() const;
-            String& operator=(char c_);
-    };
-
-    template<class T> String String::toString(const T& value_)
-    {
-        std::ostringstream ost;
-        ost << value_;
-        return ost.str();
-    }
-
-    template<> inline String String::toString<bool>(const bool& value_)
-    {
-        if(value_ == true)
-        {
-            return "TRUE";
-        }
-        else
-        {
-            return "FALSE";
-        }
-    }
-
-    inline String String::toBitString(unsigned int value_, unsigned int num_bits_)
-    {
-        std::bitset<sizeof(unsigned int)*8> bitSet(value_);
-        String ret = String(bitSet.to_string());
-        ret = ret.substr(ret.length()-num_bits_);
-        return ret;
-    }
-
-    template<class T> T String::fromString(const String& str_)
-    {
-        T ret;
-        std::istringstream ist(str_);
-        ist >> ret;
-        return ret;
-    }
-
-    template<> inline String String::fromString<String>(const String& str_)
-    {
-        return str_;
-    }
-
-    template<> inline bool String::fromString<bool>(const String& str_)
-    {
-        bool ret;
-        if((str_ == String("TRUE")) || (str_ == String("true")))
-        {
-            ret = true;
-        }
-        else if((str_ == string("FALSE")) || (str_ == String("false")))
-        {
-            ret = false;
-        }
-        else
-        {
-            //std::cerr << "Invalid bool value: " << str_ << std::endl;
-            throw ("Invalid bool value: " + str_);
-        }
-        return ret;
-    }
-
-    template<class T> String arrayToString(
-            const T* array_, unsigned int start_index_, unsigned int end_index_, 
-            const String& delimiters_
-            )
-    {
-        // Ensure end_index_ >= start_index_ + 1
-        if(end_index_ <= start_index_)
-        {
-            throw("Invalid index range: start_index = " + (String)start_index_ + ", end_index = " + (String)end_index_);
-        }
-
-        String ret = "[";
-        for(unsigned int i = start_index_; i < (end_index_-1); ++i)
-        {
-            ret += (String)array_[i] + delimiters_;
-        }
-        ret += (String)array_[end_index_-1] + "]";
-        return ret;
-    }
-
-    template<class T> String arrayToString(const T* array_, unsigned int num_elements_)
-    {
-        return arrayToString(array_, 0, num_elements_, ", ");
-    }
-
-    template<class T> String arrayToString(const T* array_, unsigned int start_index_, unsigned int end_index_)
-    {
-        return arrayToString(array_, start_index_, end_index_);
-    }
-
-    template<class T> String vectorToString(
-        const vector<T>& vector_, unsigned int start_index_, unsigned int end_index_,
-        const String& delimiters_
-        )
-    {
-        // Ensure end_index_ >= start_index_ + 1, or if the vector is empty
-        if((end_index_ <= start_index_) || (end_index_ > vector_.size()))
-        {
-            // If the vector is empty, return empty array
-            if (vector_.size() == 0)
-                return "[]";
-                
-            throw("Invalid index range: start_index = " + (String)start_index_ + ", end_index = " + (String)end_index_);
-        }
-
-        String ret = "[";
-        for(unsigned int i = start_index_; i < (end_index_-1); ++i)
-        {
-            ret += (String)vector_[i] + delimiters_;
-        }
-        ret += (String)vector_[end_index_-1] + "]";
-        return ret;
-    }
-
-    template<class T> String vectorToString(const vector<T>& vector_)
-    {
-        return vectorToString(vector_, 0, vector_.size(), ", ");
-    }
-
-    template<class T> String vectorToString(const vector<T>& vector_, unsigned int num_elements_)
-    {
-        return vectorToString(vector_, 0, num_elements_, ", ");
-    }
-
-    template<class T> String vectorToString(const vector<T>& vector_, unsigned int start_index_, unsigned int end_index_)
-    {
-        return vectorToString(vector_, start_index_, end_index_);
-    }
-
-    template<class T> vector<T> castStringVector(const vector<String>& vector_)
-    {
-        vector<T> ret_vector;
-        for(unsigned int i = 0; i < vector_.size(); ++i)
-        {
-            ret_vector.push_back((T)vector_[i]);
-        }
-        return ret_vector;
-    }
-
-    std::istream& safeGetline(std::istream& is_, String& str_);
-} // namespace LibUtil
-
-#endif // __STRING_H__
-
diff -Nur dsent0.91/libutil/libutilAssert.h ../dsent0.91/libutil/libutilAssert.h
--- dsent0.91/libutil/libutilAssert.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilAssert.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,22 @@
+#ifndef __ASSERT_H__
+#define __ASSERT_H__
+
+#include "libutilString.h"
+#include "libutilException.h"
+
+#ifdef NDEBUG
+#define ASSERT(test_value_,exception_msg_)
+#else
+#define ASSERT(test_value_,msg_) \
+    do \
+    { \
+        if(!(test_value_)) \
+        { \
+            const LibUtil::String& exception_msg = LibUtil::String::format("\nAt %s:%d\n", 0, __FILE__, __LINE__) + (String)(msg_); \
+            throw LibUtil::Exception(exception_msg); \
+        } \
+    } while(0);
+#endif
+
+#endif // __ASSERT_H__
+
diff -Nur dsent0.91/libutil/libutilCalculator.cc ../dsent0.91/libutil/libutilCalculator.cc
--- dsent0.91/libutil/libutilCalculator.cc	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilCalculator.cc	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,239 @@
+#include "libutilCalculator.h"
+
+#include <cctype>
+#include <iostream>
+
+namespace LibUtil
+{
+    using std::cout;
+    using std::endl;
+    using std::scientific;
+
+    Calculator::Calculator()
+    {
+        m_reserved_chars_ = "+-*/;=()\\";
+    }
+
+    Calculator::~Calculator()
+    {}
+
+    void Calculator::reset()
+    {
+        m_var_.clear();
+        return;
+    }
+
+    void Calculator::evaluateString(const String& str_)
+    {
+        istringstream ist(str_);
+        while(ist)
+        {
+            getToken(ist);
+            if(m_curr_token_ == END) break;
+            if(m_curr_token_ == SEP) continue;
+            if((m_curr_token_ == NAME) && (m_value_string_ == "print"))
+            {
+                getToken(ist);
+
+                if(m_curr_token_ == STRING)
+                {
+                    String print_str = m_value_string_;
+
+                    getToken(ist);
+                    if(m_curr_token_ == SEP)
+                    {
+                        cout << print_str << endl;
+                    }
+                    else
+                    {
+                        double v = expr(ist, false);
+                        cout << scientific << print_str << v << endl;
+                    }
+                }
+                else
+                {
+                    double v = expr(ist, false);
+                    cout << scientific << v << endl;
+                }
+            }
+            else
+            {
+                expr(ist, false);
+            }
+        }
+        return;
+    }
+
+    Calculator::Token Calculator::getToken(istringstream& ist_)
+    {
+        char ch;
+        do
+        {
+            ist_.get(ch);
+            if(!ist_)
+            {
+                m_curr_token_ = END;
+                return m_curr_token_;
+            }
+        }
+        while(ch != '\n' && isspace(ch));
+
+        switch(ch)
+        {
+            case '\n':
+                m_curr_token_ = END;
+                return m_curr_token_;
+            case ';':
+                m_curr_token_ = SEP;
+                return m_curr_token_;
+            case '*':
+            case '/':
+            case '+':
+            case '-':
+            case '(':
+            case ')':
+            case '=':
+                m_curr_token_ = Token(ch);
+                return m_curr_token_;
+            case '0': case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+            case '.':
+                ist_.putback(ch);
+                ist_ >> m_value_number_;
+                m_curr_token_ = NUMBER;
+                return m_curr_token_;
+            case '"':
+                ist_.get(ch);
+                m_value_string_ = "";
+                while(ist_ && ('"' != ch))
+                {
+                    m_value_string_ += String(1, ch);
+                    ist_.get(ch);
+                }
+                m_curr_token_ = STRING;
+                return m_curr_token_;
+            case '$':
+                ist_.get(ch);
+                ASSERT((ch == '('), "[Error] Bad token: '(' expected");
+                ist_.get(ch);
+                m_value_string_ = "";
+                while(ist_ && (!isspace(ch)) && (')' != ch))
+                {
+                    m_value_string_ += String(1, ch);
+                    ist_.get(ch);
+                }
+                m_curr_token_ = NAME2;
+                return m_curr_token_;
+            default:
+                if(isalpha(ch))
+                {
+                    m_value_string_ = ch;
+                    ist_.get(ch);
+                    while(ist_ && (isalnum(ch) || ('_' == ch)))
+                    {
+                        m_value_string_ += String(1, ch);
+                        ist_.get(ch);
+                    }
+                    ist_.putback(ch);
+                    m_curr_token_ = NAME;
+                    return m_curr_token_;
+                }
+                else
+                {
+                    String error_msg = "[Error] Bad token: '" + String(ch) + "'";
+                    throw Exception(error_msg);
+                }
+        }
+    }
+
+    double Calculator::prim(istringstream& ist_, bool is_get_)
+    {
+        if(is_get_)
+        {
+            getToken(ist_);
+        }
+
+        double v;
+        switch(m_curr_token_)
+        {
+            case NUMBER:
+                v = m_value_number_;
+                getToken(ist_);
+                return v;
+            case NAME:
+                if(getToken(ist_) == ASSIGN)
+                {
+                    String var_name = m_value_string_;
+                    v = expr(ist_, true);
+                    m_var_.set(var_name, v);
+                }
+                else
+                {
+                    v = m_var_.get(m_value_string_);
+                }
+                return v;
+            case NAME2:
+                v = getEnvVar(m_value_string_);
+                getToken(ist_);
+                return v;
+            case MINUS:
+                return -prim(ist_, true);
+            case LP:
+                v = expr(ist_, true);
+                ASSERT((m_curr_token_ == RP), "[Error] ')' expected");
+                getToken(ist_);
+                return v;
+            default:
+                ASSERT(0, "[Error] primary expected, get: '" + String(int(m_curr_token_)) + "'");
+        }
+    }
+
+    double Calculator::term(istringstream& ist_, bool is_get_)
+    {
+        double left = prim(ist_, is_get_);
+
+        while(1)
+        {
+            double d;
+            switch(m_curr_token_)
+            {
+                case MUL:
+                    left *= prim(ist_, true);
+                    break;
+                case DIV:
+                    d = prim(ist_, true);
+                    ASSERT(d, "[Error] divided by 0");
+                    left /= d;
+                    break;
+                default:
+                    return left;
+            }
+        }
+    }
+
+    double Calculator::expr(istringstream& ist_, bool is_get_)
+    {
+        double left = term(ist_, is_get_);
+
+        while(1)
+        {
+            switch(m_curr_token_)
+            {
+                case PLUS:
+                    left += term(ist_, true);
+                    break;
+                case MINUS:
+                    left -= term(ist_, true);
+                    break;
+                default:
+                    return left;
+            }
+        }
+    }
+
+    double Calculator::getEnvVar(const String& var_name_) const
+    {
+        return m_var_.get(var_name_);
+    }
+} // namespace LibUtil
+
diff -Nur dsent0.91/libutil/libutilCalculator.h ../dsent0.91/libutil/libutilCalculator.h
--- dsent0.91/libutil/libutilCalculator.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilCalculator.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,86 @@
+#ifndef __LIBUTIL_CALCULATOR_H__
+#define __LIBUTIL_CALCULATOR_H__
+
+#include <sstream>
+
+#include "libutilString.h"
+#include "libutilMap.h"
+#include "libutilAssert.h"
+
+namespace LibUtil
+{
+    using std::istringstream;
+
+    /*
+     *  program:
+     *      END                         // END is end-of-input
+     *      expr_list END
+     *
+     *  expr_list:
+     *      expression SEP expr_list    // SEP is semicolon
+     *      expression                  
+     *      print expression
+     *      print STRING
+     *      print STRING expression
+     *      print STRING expression SEP expr_list
+     *
+     *
+     *  expression:
+     *      expression + term
+     *      expression - term
+     *      term
+     *
+     *  term:
+     *      term / primary
+     *      term * primary
+     *      primary
+     *
+     *  primary:
+     *      NUMBER
+     *      NAME
+     *      NAME = expression
+     *      NAME string expression      // NAME is print
+     *      - primary
+     *      ( expression )
+     *
+     *  string:
+     *      
+     **/
+
+    class Calculator
+    {
+        protected:
+            enum Token
+            {
+                NAME, NAME2, NUMBER, STRING, END,
+                PLUS = '+', MINUS = '-', MUL = '*', DIV = '/',
+                SEP = ';', ASSIGN = '=', LP = '(', RP = ')'
+            };
+
+        public:
+            Calculator();
+            virtual ~Calculator();
+
+        public:
+            void reset();
+            void evaluateString(const String& str_);
+
+        protected:
+            Token getToken(istringstream& ist_);
+            double prim(istringstream& ist_, bool is_get_);
+            double term(istringstream& ist_, bool is_get_);
+            double expr(istringstream& ist_, bool is_get_);
+            virtual double getEnvVar(const String& var_name_) const;
+
+        protected:
+            String m_reserved_chars_;
+            Map<double> m_var_;
+
+            Token m_curr_token_;
+            double m_value_number_;
+            String m_value_string_;
+    }; // class Calculator
+} // namespace LibUtil
+
+#endif // __LIBUTIL_CALCULATOR_H__
+
diff -Nur dsent0.91/libutil/libutilConfig.cc ../dsent0.91/libutil/libutilConfig.cc
--- dsent0.91/libutil/libutilConfig.cc	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilConfig.cc	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,144 @@
+#include "libutilConfig.h"
+
+#include <fstream>
+
+#include "libutilAssert.h"
+
+namespace LibUtil
+{
+    Config::Config(const String& delimiter_, const String& comment_, const String& sentry_)
+        : mDelimiter(delimiter_), mComment(comment_), mSentry(sentry_)
+    {}
+
+    Config::Config(const Config& config_)
+        : StringMap(config_)
+    {
+        mDelimiter = config_.mDelimiter;
+        mComment = config_.mComment;
+        mSentry = config_.mSentry;
+    }
+
+    Config::~Config()
+    {}
+
+    Config* Config::clone() const
+    {
+        return new Config(*this);
+    }
+
+    void Config::readFile(const String& filename_)
+    {
+        std::ifstream fin(filename_.c_str());
+
+        ASSERT(fin, "File not found: " + filename_);
+        fin >> (*this);
+        return;
+    }
+
+    void Config::readString(const String& str_)
+    {
+        String newString = str_;
+        newString.substitute(";", "\n");
+        std::istringstream iss(newString, std::istringstream::in);
+
+        iss >> (*this);
+    }
+
+    std::ostream& operator<<(std::ostream& ost_, const Config& config_)
+    {
+        Config::ConstIterator it;
+        for(it = config_.begin(); it != config_.end(); it++)
+        {
+            ost_ << it->first << " " << config_.mDelimiter << " ";
+            ost_ << it->second << std::endl;
+        }
+        return ost_;
+    }
+
+    std::istream& operator>>(std::istream& ist_, Config& config_)
+    {
+        // Set a Config from ist_
+        // Read in keys and values, keeping internal whitespace
+        typedef String::size_type pos;
+        const String& delim  = config_.mDelimiter;  // separator
+        const String& comm   = config_.mComment;    // comment
+        const String& sentry = config_.mSentry;     // end of file sentry
+        const pos skip = delim.length();        // length of separator
+
+        String nextline = "";  // might need to read ahead to see where value ends
+
+        while(ist_ || nextline.length() > 0)
+        {
+            // Read an entire line at a time
+            String line;
+            if(nextline.length() > 0)
+            {
+                line = nextline;  // we read ahead; use it now
+                nextline = "";
+            }
+            else
+            {
+                //std::getline(ist_, line);
+                safeGetline(ist_, line);
+            }
+
+            // Ignore comments and the spaces on both ends
+            line = line.substr(0, line.find(comm));
+            line.trim();
+
+            // Check for end of file sentry
+            if((sentry != "") && (line.find(sentry) != String::npos)) return ist_;
+
+            if(line.length() == 0)
+                continue;
+
+            // Parse the line if it contains a delimiter
+            pos delimPos = line.find(delim);
+            ASSERT((delimPos < String::npos), "Invalid config line: '" + line + "'");
+
+            // Extract the key
+            String key = line.substr(0, delimPos);
+            line.replace(0, delimPos+skip, "");
+
+            // See if value continues on the next line
+            // Stop at blank line, next line with a key, end of stream,
+            // or end of file sentry
+            bool terminate = false;
+            while(!terminate && ist_)
+            {
+                if(line.at(line.size() - 1) == '\\')
+                    line.erase(line.size() - 1);
+                else
+                    break;
+
+                //std::getline(ist_, nextline);
+                safeGetline(ist_, nextline);
+                terminate = true;
+
+                String nlcopy = nextline;
+                nlcopy.trim();
+                if(nlcopy == "") continue;
+
+                nextline = nextline.substr(0, nextline.find(comm));
+                //if(nextline.find(delim) != String::npos)
+                //    continue;
+                if((sentry != "") && (nextline.find(sentry) != String::npos))
+                    continue;
+
+                //nlcopy = nextline;
+                //nlcopy.trim();
+                //if(nlcopy != "") line += "\n";
+                line += nextline;
+                nextline = "";
+                terminate = false;
+            }
+
+            // Store key and value
+            key.trim();
+            line.trim();
+            config_.set(key, line);  // overwrites if key is repeated
+        }
+        return ist_;
+    }
+}
+
diff -Nur dsent0.91/libutil/libutilConfig.h ../dsent0.91/libutil/libutilConfig.h
--- dsent0.91/libutil/libutilConfig.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilConfig.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,37 @@
+#ifndef __LIBUTIL_CONFIG_H__
+#define __LIBUTIL_CONFIG_H__
+
+#include <iostream>
+
+#include "libutilMap.h"
+
+namespace LibUtil
+{
+    class Config : public StringMap
+    {
+        public:
+            Config(const String& delimiter_ = "=", const String& comment_ = "#", const String& sentry_ = "End");
+            Config(const Config& config_);
+            virtual ~Config();
+
+        public:
+            // Make a copy of this instance
+            virtual Config* clone() const;
+            // Load the config from file
+            virtual void readFile(const String& filename_);
+            // Parse string and overwrite the Config instance if keys exist
+            virtual void readString(const String& str_);
+
+            // Write or read map using standard IO
+            friend std::ostream& operator<<(std::ostream& ost_, const Config& config_);
+            friend std::istream& operator>>(std::istream& ist_, Config& config_);
+
+        protected:
+            String mDelimiter;
+            String mComment;
+            String mSentry;
+    };
+}
+
+#endif // __LIBUTIL_CONFIG_H__
+
diff -Nur dsent0.91/libutil/libutilException.cc ../dsent0.91/libutil/libutilException.cc
--- dsent0.91/libutil/libutilException.cc	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilException.cc	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,17 @@
+#include "libutilException.h"
+
+namespace LibUtil
+{
+    Exception::Exception(const String& exception_msg_) throw()
+        : exception(), mExceptionMsg(exception_msg_)
+    {}
+
+    Exception::~Exception() throw()
+    {}
+
+    const char* Exception::what() const throw()
+    {
+        return mExceptionMsg.c_str();
+    }
+}
+
diff -Nur dsent0.91/libutil/libutilException.h ../dsent0.91/libutil/libutilException.h
--- dsent0.91/libutil/libutilException.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilException.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,29 @@
+#ifndef __LIBUTIL_EXCEPTION_H__
+#define __LIBUTIL_EXCEPTION_H__
+
+#include <exception>
+
+#include "libutilString.h"
+
+namespace LibUtil
+{
+    using std::exception;
+
+    // Exception class handles the all exception messages in the program
+    class Exception : public exception
+    {
+        public:
+            // All constructors/destructors/functions in this class don't throw any events
+            Exception(const String& exception_msg_) throw();
+            ~Exception() throw();
+
+            // Derived from std::exception class that returns a null-terminated char string
+            const char* what() const throw();
+
+        private:
+            String mExceptionMsg;
+    };
+}
+
+#endif // __EXCEPTION_H__
+
diff -Nur dsent0.91/libutil/libutilLog.cc ../dsent0.91/libutil/libutilLog.cc
--- dsent0.91/libutil/libutilLog.cc	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilLog.cc	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,85 @@
+#include "libutilLog.h"
+#include "libutilAssert.h"
+
+namespace LibUtil
+{
+    using std::ostream;
+    using std::endl;
+
+    Log* Log::msSingleton = NULL;
+    const bool Log::msIsLog = LIBUTIL_IS_LOG;
+
+    void Log::allocate(const String& log_file_name_)
+    {
+        if(msIsLog)
+        {
+            // Allocate static Config instance
+            ASSERT(!msSingleton, "Log singleton is allocated");
+            msSingleton = new Log(log_file_name_);
+        }
+    }
+
+    void Log::release()
+    {
+        if(msIsLog)
+        {
+            ASSERT(msSingleton, "Log singleton is not allocated");
+            delete msSingleton;
+            msSingleton = NULL;
+        }
+        return;
+    }
+
+    void Log::print(const String& str_)
+    {
+        if(msIsLog)
+        {
+            ASSERT(msSingleton, "Log singleton is not allocated");
+            msSingleton->ofs << str_;
+        }
+        return;
+    }
+
+    void Log::print(ostream& stream_, const String& str_)
+    {
+        if(msIsLog)
+        {
+            ASSERT(msSingleton, "Log singleton is not allocated");
+            msSingleton->ofs << str_;
+        }
+        stream_ << str_;
+        return;
+    }
+
+    void Log::printLine(const String& str_)
+    {
+        if(msIsLog)
+        {
+            ASSERT(msSingleton, "Log singleton is not allocated");
+            msSingleton->ofs << str_ << endl;
+        }
+        return;
+    }
+
+    void Log::printLine(ostream& stream_, const String& str_)
+    {
+        if(msIsLog)
+        {
+            ASSERT(msSingleton, "Log singleton is not allocated");
+            msSingleton->ofs << str_ << endl;
+        }
+        stream_ << str_ << endl;
+        return;
+    }
+
+    Log::Log(const String& log_file_name_)
+    {
+        ofs.open(log_file_name_.c_str());
+    }
+
+    Log::~Log()
+    {
+        ofs.close();
+    }
+}
+
diff -Nur dsent0.91/libutil/libutilLog.h ../dsent0.91/libutil/libutilLog.h
--- dsent0.91/libutil/libutilLog.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilLog.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,43 @@
+#ifndef __LIBUTIL_LOG_H__
+#define __LIBUTIL_LOG_H__
+
+#include <cstdio>
+#include <iostream>
+#include <fstream>
+
+#include "libutilString.h"
+
+#ifndef LIBUTIL_IS_LOG
+#define LIBUTIL_IS_LOG false
+#endif
+
+namespace LibUtil
+{
+    using std::cerr;
+
+    class Log
+    {
+        public:
+            static void allocate(const String& log_file_name_);
+            static void release();
+
+            static void print(const String& str_);
+            static void print(std::ostream& stream_, const String& str_);
+            static void printLine(const String& str_);
+            static void printLine(std::ostream& stream_, const String& str_);
+
+        protected:
+            static Log* msSingleton;
+            static const bool msIsLog;
+
+        protected:
+            Log(const String& log_file_name_);
+            ~Log();
+
+        protected:
+            std::ofstream ofs;
+    };
+}
+
+#endif // __LOG_H__
+
diff -Nur dsent0.91/libutil/libutilMap.h ../dsent0.91/libutil/libutilMap.h
--- dsent0.91/libutil/libutilMap.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilMap.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,242 @@
+#ifndef __LIBUTIL_MAP_H__
+#define __LIBUTIL_MAP_H__
+
+#include <iostream>
+#include <map>
+
+#include "libutilString.h"
+#include "libutilAssert.h"
+
+namespace LibUtil
+{
+    using std::map;
+
+    template<class T> class Map
+    {
+        public:
+            typedef typename map<String, T>::iterator       Iterator;
+            typedef typename map<String, T>::const_iterator ConstIterator;
+            typedef typename map<String, T>::size_type      SizeType;
+
+        public:
+            Map();
+            virtual ~Map();
+
+        public:
+            // Return a new copy of this Map instance
+            Map* clone() const;
+            // Copy map_ to this instance
+            void copyFrom(const Map<T>* map_);
+            // Return the size of the map
+            SizeType size() const;
+            // Check if the map is empty
+            bool isEmpty() const;
+            // Check if the key exists
+            bool keyExist(const String& key_) const;
+            // Get the value_ corresponding to the key_
+            const T& get(const String& key_) const;
+            // Get the value_ corresponding to the key_ if the key_ exist, otherwise, the default_value_is returned
+            const T& getIfKeyExist(const String& key_, const T& default_value_ = T()) const;
+            // Add/Update a <key_, value_> entry
+            void set(const String& key_, const T& value_);
+            // Get iterator to the element
+            Iterator find(const String& key_);
+            ConstIterator find(const String& key_) const;
+            // Remove an entry corresponding to key_
+            void remove(const String& key_);
+            // Remove an entry at 'it' 
+            void remove(Iterator it);
+            // Remove all keys
+            void clear();
+            // Merge a map. Values with same key will be overwritten.
+            void merge(const Map<T>* map_);
+            // Returns a MapIterator referring to the first element in the map
+            Iterator begin();
+            ConstIterator begin() const;
+            // Returns a MapIterator referring to the past-the-end element in the map
+            Iterator end();
+            ConstIterator end() const;
+
+        protected:
+            Map(const Map& map_);
+
+        protected:
+            map<String, T> mMap;
+    };
+
+    template<class T> Map<T>::Map()
+    {}
+
+    template<class T> Map<T>::~Map()
+    {}
+
+    template<class T> Map<T>* Map<T>::clone() const
+    {
+        return new Map<T>(*this);
+    }
+
+    template<class T> void Map<T>::copyFrom(const Map<T>* map_)
+    {
+        // Remove all keys (it won't free the content if T is a pointer)
+        mMap.clear();
+
+        // Copy the contents
+        mMap = map_->mMap;
+    }
+
+    template<class T> typename Map<T>::SizeType Map<T>::size() const
+    {
+        return mMap.size();
+    }
+
+    template<class T> bool Map<T>::isEmpty() const
+    {
+        return (mMap.empty());
+    }
+
+    template<class T> bool Map<T>::keyExist(const String& key_) const
+    {
+        ConstIterator it = mMap.find(key_);
+        return (it != mMap.end());
+    }
+
+    template<class T> const T& Map<T>::get(const String& key_) const
+    {
+        ConstIterator it;
+
+        it = mMap.find(key_);
+        ASSERT((it != mMap.end()), "Key not found: " + key_);
+        return (it->second);
+    }
+
+    template<class T> const T& Map<T>::getIfKeyExist(const String& key_, const T& default_value_) const
+    {
+        if(keyExist(key_))
+        {
+            return get(key_);
+        }
+        else
+        {
+            return default_value_;
+        }
+    }
+
+    template<class T> void Map<T>::set(const String& key_, const T& value_)
+    {
+        mMap[key_] = value_;
+        return;
+    }
+
+    template<class T> typename Map<T>::Iterator Map<T>::find(const String& key_)
+    {
+        return mMap.find(key_);
+    }
+
+    template<class T> typename Map<T>::ConstIterator Map<T>::find(const String& key_) const
+    {
+        return mMap.find(key_);
+    }
+
+    template<class T> void Map<T>::remove(const String& key_)
+    {
+        mMap.erase(key_);
+        return;
+    }
+
+    template<class T> void Map<T>::remove(Iterator it)
+    {
+        mMap.erase(it);
+        return;
+    }
+
+    template<class T> void Map<T>::clear()
+    {
+        mMap.clear();
+        return;
+    }
+
+    template<class T> void Map<T>::merge(const Map<T>* map_)
+    {
+        ConstIterator it;
+        for(it = map_->begin(); it != map_->end(); it++)
+        {
+            const String& key = it->first;
+            const T& value = it->second;
+            set(key, value);
+        }
+        return;
+    }
+
+    template<class T> typename Map<T>::Iterator Map<T>::begin()
+    {
+        return mMap.begin();
+    }
+
+    template<class T> typename Map<T>::ConstIterator Map<T>::begin() const
+    {
+        return mMap.begin();
+    }
+
+    template<class T> typename Map<T>::Iterator Map<T>::end()
+    {
+        return mMap.end();
+    }
+
+    template<class T> typename Map<T>::ConstIterator Map<T>::end() const
+    {
+        return mMap.end();
+    }
+
+    inline std::ostream& operator<<(std::ostream& ost_, const Map<String>& map_)
+    {
+        Map<String>::ConstIterator it;
+        for(it = map_.begin(); it != map_.end(); it++)
+        {
+            ost_ << it->first << " = " << it->second << std::endl;
+        }
+        return ost_;
+    }
+
+    template<class T> Map<T>::Map(const Map<T>& map_)
+        : mMap(map_.mMap)
+    {}
+
+    typedef Map<String> StringMap;
+
+
+    // Handy function to delete all pointers in a map
+    template<class T> void clearPtrMap(Map<T*>* map_)
+    {
+        for(typename Map<T*>::Iterator it = map_->begin(); it != map_->end(); ++it)
+        {
+            T* temp_T = it->second;
+            delete temp_T;
+        }
+        map_->clear();
+        return;
+    }
+
+    // Handy function to delete all pointers in a map and the map itself
+    template<class T> void deletePtrMap(Map<T*>* map_)
+    {
+        clearPtrMap<T>(map_);
+        delete map_;
+        return;
+    }
+
+    // Handy function to clone all pointers in a map
+    template<class T> Map<T*>* clonePtrMap(const Map<T*>* map_)
+    {
+        Map<T*>* new_T_map = new Map<T*>;
+        for(typename Map<T*>::ConstIterator it = map_->begin(); it != map_->end(); ++it)
+        {
+            const String& temp_name = it->first;
+            const T* temp_T = it->second;
+            new_T_map->set(temp_name, temp_T->clone());
+        }
+        return new_T_map;
+    }
+}
+
+#endif // __MAP_H__
+
diff -Nur dsent0.91/libutil/libutilString.cc ../dsent0.91/libutil/libutilString.cc
--- dsent0.91/libutil/libutilString.cc	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilString.cc	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,347 @@
+#include "libutilString.h"
+
+#include <cstdarg>
+#include <cstdio>
+#include <iostream>
+#include <ios>
+
+namespace LibUtil
+{
+    const unsigned int String::msBufferSize = 4096;
+
+    String String::format(const String& format_, int dummy, ...)
+    {
+        char buffer[msBufferSize];
+
+        va_list args;
+        va_start(args, dummy);
+        vsnprintf(buffer, msBufferSize, format_.c_str(), args);
+        va_end(args);
+
+        return (String)(buffer);
+    }
+
+    String String::format(const String& format_, va_list args_)
+    {
+        char buffer[msBufferSize];
+
+        vsnprintf(buffer, msBufferSize, format_.c_str(), args_);
+
+        return (String)(buffer);
+    }
+
+    String::String()
+    {}
+
+    String::String(const string& str_)
+        : string(str_)
+    {}
+
+    String::String(const char* str_, size_t n_)
+        : string(str_, n_)
+    {}
+
+    String::String(const char* str_)
+        : string(str_)
+    {}
+
+    String::String(size_t n_, char c_)
+        : string(n_, c_)
+    {}
+
+    String::String(int value_)
+        : string(toString<int>(value_))
+    {}
+
+    String::String(unsigned int value_)
+        : string(toString<unsigned int>(value_))
+    {}
+
+    String::String(long value_)
+        : string(toString<long>(value_))
+    {}
+
+    String::String(unsigned long value_)
+        : string(toString<unsigned long>(value_))
+    {}
+
+    String::String(float value_)
+        : string(toString<float>(value_))
+    {}
+
+    String::String(double value_)
+        : string(toString<double>(value_))
+    {}
+
+    String::String(bool value_)
+        : string(toString<bool>(value_))
+    {}
+
+    String::~String()
+    {}
+
+    String& String::trim()
+    {
+        // Remove leading and trailing whitespace
+        static const char whitespace[] = " \n\t\v\r\f";
+        erase(0, find_first_not_of(whitespace));
+        erase(find_last_not_of(whitespace) + 1U);
+        return (*this);
+    }
+
+    String& String::substitute(const String& str1_, const String& str2_)
+    {
+        size_t str1Size = str1_.size();
+        size_t str2Size = str2_.size();
+
+        size_t pos;
+        pos = find(str1_);
+        while(pos != string::npos)
+        {
+            replace(pos, str1Size, str2_);
+            pos += str2Size;
+            pos = find(str1_, pos);
+        }
+        return (*this);
+    }
+
+    vector<String> String::split(const char* delimiters_) const
+    {
+        vector<String> result;
+
+        if(size() == 0)
+        {
+            return result;
+        }
+
+        size_t currPos, nextPos;
+        currPos = 0;
+        nextPos = find_first_of(delimiters_);
+        while(1)
+        {
+            if(nextPos == string::npos)
+            {
+                if(currPos != size())
+                {
+                    result.push_back(substr(currPos));
+                }
+                break;
+            }
+
+            if(nextPos != currPos)
+            {
+                result.push_back(substr(currPos, nextPos - currPos));
+            }
+            currPos = nextPos + 1;
+            nextPos = find_first_of(delimiters_, currPos);
+        }
+
+        return result;
+    }
+
+    vector<String> String::split(const String* delimiters_, unsigned int num_delimiters_) const
+    {
+        vector<String> result;
+
+        if(size() == 0)
+        {
+            return result;
+        }
+
+        if(num_delimiters_ == 1)
+        {
+            size_t currPos, nextPos;
+            currPos = 0;
+            nextPos = find(delimiters_[0]);
+            while(1)
+            {
+                if(nextPos == String::npos)
+                {
+                    result.push_back(substr(currPos));
+                    break;
+                }
+
+                if(nextPos != currPos)
+                {
+                    result.push_back(substr(currPos, nextPos - currPos));
+                }
+                currPos = nextPos + delimiters_[0].size();
+                nextPos = find(delimiters_[0], currPos);
+            }
+        }
+        else
+        {
+            // Currently the length of the delimiters are not checked
+            unsigned int delimiterLength = 0;
+            size_t currPos, nextPos;
+            currPos = 0;
+            nextPos = size();
+            for(unsigned int i = 0; i < num_delimiters_; ++i)
+            {
+                size_t tempPos = find(delimiters_[i], currPos);
+                if((tempPos != String::npos) && (tempPos < nextPos))
+                {
+                    nextPos = tempPos;
+                    delimiterLength = delimiters_[i].size();
+                }
+            }
+            while(1)
+            {
+                if((nextPos == String::npos) || (nextPos == size()))
+                {
+                    result.push_back(substr(currPos));
+                    break;
+                }
+
+                if(nextPos != currPos)
+                {
+                    result.push_back(substr(currPos, nextPos - currPos));
+                }
+                currPos = nextPos + delimiterLength;
+                nextPos = size();
+                delimiterLength = 0;
+                for(unsigned int i = 0; i < num_delimiters_; ++i)
+                {
+                    size_t tempPos = find(delimiters_[i], currPos);
+                    if((tempPos != String::npos) && (tempPos < nextPos))
+                    {
+                        nextPos = tempPos;
+                        delimiterLength = delimiters_[i].size();
+                    }
+                }
+            }
+        }
+        return result;
+    }
+
+    vector<String> String::splitByString(const String& delimiter_) const
+    {
+        return split(&delimiter_, 1);
+    }
+
+    bool String::contain(const String& str_) const
+    {
+        return (find(str_) != String::npos);
+    }
+
+    const char* String::toCString() const
+    {
+        return this->c_str();
+    }
+
+    int String::toInt() const
+    {
+        return fromString<int>(*this);
+    }
+
+    unsigned int String::toUInt() const
+    {
+        return fromString<unsigned int>(*this);
+    }
+
+    long String::toLong() const
+    {
+        return fromString<long>(*this);
+    }
+
+    unsigned long String::toULong() const
+    {
+        return fromString<unsigned long>(*this);
+    }
+
+    float String::toFloat() const
+    {
+        return fromString<float>(*this);
+    }
+
+    double String::toDouble() const
+    {
+        return fromString<double>(*this);
+    }
+
+    bool String::toBool() const
+    {
+        return fromString<bool>(*this);
+    }
+
+    String::operator const char*() const
+    {
+        return this->c_str();
+    }
+
+    String::operator int() const
+    {
+        return fromString<int>(*this);
+    }
+
+    String::operator unsigned int() const
+    {
+        return fromString<unsigned int>(*this);
+    }
+
+    String::operator long() const
+    {
+        return fromString<long>(*this);
+    }
+
+    String::operator unsigned long() const
+    {
+        return fromString<unsigned long>(*this);
+    }
+
+    String::operator float() const
+    {
+        return fromString<float>(*this);
+    }
+
+    String::operator double() const
+    {
+        return fromString<double>(*this);
+    }
+
+    String::operator bool() const
+    {
+        return fromString<bool>(*this);
+    }
+
+    String& String::operator=(char c_)
+    {
+        this->assign(1, c_);
+        return *this;
+    }
+
+    std::istream& safeGetline(std::istream& is_, String& str_)
+    {
+        str_.clear();
+
+        // The characters in the stream are read one-by-one using a std::streambuf.
+        // That is faster than reading them one-by-one using the std::istream.
+        // Code that uses streambuf this way must be guarded by a sentry object.
+        // The sentry object performs various tasks,
+        // such as thread synchronization and updating the stream state.
+
+        std::istream::sentry se(is_, true);
+        std::streambuf* sb = is_.rdbuf();
+
+        while(1)
+        {
+            int c = sb->sbumpc();
+            switch(c)
+            {
+                case '\r':
+                    c = sb->sgetc();
+                    if(c == '\n')
+                        sb->sbumpc();
+                    return is_;
+                case '\n':
+                    return is_;
+                case EOF:
+                    is_.setstate(std::ios_base::failbit|std::ios_base::eofbit);
+                    return is_;
+                default:
+                    str_ += String(1, (char)c);
+            }
+        }
+    }
+} // namespace LibUtil
+
diff -Nur dsent0.91/libutil/libutilString.h ../dsent0.91/libutil/libutilString.h
--- dsent0.91/libutil/libutilString.h	1969-12-31 19:00:00.000000000 -0500
+++ ../dsent0.91/libutil/libutilString.h	2015-04-24 20:18:56.000000000 -0400
@@ -0,0 +1,218 @@
+#ifndef __LIBUTIL_STRING_H__
+#define __LIBUTIL_STRING_H__
+
+#include <string>
+#include <cstdarg>
+#include <vector>
+#include <sstream>
+#include <bitset>
+
+namespace LibUtil
+{
+    using std::string;
+    using std::vector;
+
+    class String : public string
+    {
+        public:
+            static String format(const String& format_, int dummy, ...);
+            static String format(const String& format_, va_list args_);
+            template<class T> static String toString(const T& value_);
+            static String toBitString(unsigned int value_, unsigned int num_bits_);
+            template<class T> static T fromString(const String& str_);
+
+        private:
+            static const unsigned int msBufferSize;
+
+        public:
+            String();
+            String(const string& str_);
+            String(const char* str_, size_t n);
+            String(const char* str_);
+            String(size_t n, char c);
+            String(int value_);
+            String(unsigned int value_);
+            String(long value_);
+            String(unsigned long value_);
+            String(float value_);
+            String(double value_);
+            String(bool value_);
+            ~String();
+
+        public:
+            // Remove leading and trailing whitespace
+            String& trim();
+            // Substitute str1 with str2
+            String& substitute(const String& str1_, const String& str2_);
+            // Split the String into vector of Strings separated by delimiters_
+            vector<String> split(const char* delimiters_) const;
+            vector<String> split(const String* delimiters_, unsigned int num_delimiters_ = 1) const;
+            vector<String> splitByString(const String& delimiters_) const;
+
+            // Check if contains str
+            bool contain(const String& str_) const;
+
+        public:
+            // Convertions
+            const char* toCString() const;
+            int toInt() const;
+            unsigned int toUInt() const;
+            long toLong() const;
+            unsigned long toULong() const;
+            float toFloat() const;
+            double toDouble() const;
+            bool toBool() const;
+            operator const char*() const;
+            operator int() const;
+            operator unsigned int() const;
+            operator long() const;
+            operator unsigned long() const;
+            operator float() const;
+            operator double() const;
+            operator bool() const;
+            String& operator=(char c_);
+    };
+
+    template<class T> String String::toString(const T& value_)
+    {
+        std::ostringstream ost;
+        ost << value_;
+        return ost.str();
+    }
+
+    template<> inline String String::toString<bool>(const bool& value_)
+    {
+        if(value_ == true)
+        {
+            return "TRUE";
+        }
+        else
+        {
+            return "FALSE";
+        }
+    }
+
+    inline String String::toBitString(unsigned int value_, unsigned int num_bits_)
+    {
+        std::bitset<sizeof(unsigned int)*8> bitSet(value_);
+        String ret = String(bitSet.to_string());
+        ret = ret.substr(ret.length()-num_bits_);
+        return ret;
+    }
+
+    template<class T> T String::fromString(const String& str_)
+    {
+        T ret;
+        std::istringstream ist(str_);
+        ist >> ret;
+        return ret;
+    }
+
+    template<> inline String String::fromString<String>(const String& str_)
+    {
+        return str_;
+    }
+
+    template<> inline bool String::fromString<bool>(const String& str_)
+    {
+        bool ret;
+        if((str_ == String("TRUE")) || (str_ == String("true")))
+        {
+            ret = true;
+        }
+        else if((str_ == String("FALSE")) || (str_ == String("false")))
+        {
+            ret = false;
+        }
+        else
+        {
+            //std::cerr << "Invalid bool value: " << str_ << std::endl;
+            throw ("Invalid bool value: " + str_);
+        }
+        return ret;
+    }
+
+    template<class T> String arrayToString(
+            const T* array_, unsigned int start_index_, unsigned int end_index_, 
+            const String& delimiters_
+            )
+    {
+        // Ensure end_index_ >= start_index_ + 1
+        if(end_index_ <= start_index_)
+        {
+            throw("Invalid index range: start_index = " + (String)start_index_ + ", end_index = " + (String)end_index_);
+        }
+
+        String ret = "[";
+        for(unsigned int i = start_index_; i < (end_index_-1); ++i)
+        {
+            ret += (String)array_[i] + delimiters_;
+        }
+        ret += (String)array_[end_index_-1] + "]";
+        return ret;
+    }
+
+    template<class T> String arrayToString(const T* array_, unsigned int num_elements_)
+    {
+        return arrayToString(array_, 0, num_elements_, ", ");
+    }
+
+    template<class T> String arrayToString(const T* array_, unsigned int start_index_, unsigned int end_index_)
+    {
+        return arrayToString(array_, start_index_, end_index_);
+    }
+
+    template<class T> String vectorToString(
+        const vector<T>& vector_, unsigned int start_index_, unsigned int end_index_,
+        const String& delimiters_
+        )
+    {
+        // Ensure end_index_ >= start_index_ + 1, or if the vector is empty
+        if((end_index_ <= start_index_) || (end_index_ > vector_.size()))
+        {
+            // If the vector is empty, return empty array
+            if (vector_.size() == 0)
+                return "[]";
+                
+            throw("Invalid index range: start_index = " + (String)start_index_ + ", end_index = " + (String)end_index_);
+        }
+
+        String ret = "[";
+        for(unsigned int i = start_index_; i < (end_index_-1); ++i)
+        {
+            ret += (String)vector_[i] + delimiters_;
+        }
+        ret += (String)vector_[end_index_-1] + "]";
+        return ret;
+    }
+
+    template<class T> String vectorToString(const vector<T>& vector_)
+    {
+        return vectorToString(vector_, 0, vector_.size(), ", ");
+    }
+
+    template<class T> String vectorToString(const vector<T>& vector_, unsigned int num_elements_)
+    {
+        return vectorToString(vector_, 0, num_elements_, ", ");
+    }
+
+    template<class T> String vectorToString(const vector<T>& vector_, unsigned int start_index_, unsigned int end_index_)
+    {
+        return vectorToString(vector_, start_index_, end_index_);
+    }
+
+    template<class T> vector<T> castStringVector(const vector<String>& vector_)
+    {
+        vector<T> ret_vector;
+        for(unsigned int i = 0; i < vector_.size(); ++i)
+        {
+            ret_vector.push_back((T)vector_[i]);
+        }
+        return ret_vector;
+    }
+
+    std::istream& safeGetline(std::istream& is_, String& str_);
+} // namespace LibUtil
+
+#endif // __STRING_H__
+
diff -Nur dsent0.91/model/Model.cc ../dsent0.91/model/Model.cc
--- dsent0.91/model/Model.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/Model.cc	2015-04-24 20:18:56.000000000 -0400
@@ -218,6 +218,14 @@
             " -> Cannot set parameters after model is constructed!");
         m_parameters_->set(parameter_name_, parameter_value_);
     }
+    
+    void Model::updateParameter(const String& parameter_name_, const String& parameter_value_)
+    {
+        ASSERT(m_constructed_, "[Error] " + getInstanceName() + 
+            " -> Cannot update parameters before model is constructed!");
+        m_parameters_->remove(parameter_name_);
+        m_parameters_->set(parameter_name_, parameter_value_);
+    }
     //-------------------------------------------------------------------------
     
     //-------------------------------------------------------------------------
@@ -242,6 +250,7 @@
     }
     //-------------------------------------------------------------------------
             
+            
     PropertyMap* Model::getGenProperties()
     {
         return m_generated_properties_;
diff -Nur dsent0.91/model/Model.h ../dsent0.91/model/Model.h
--- dsent0.91/model/Model.h	2012-05-20 22:40:36.000000000 -0400
+++ ../dsent0.91/model/Model.h	2015-04-24 20:18:56.000000000 -0400
@@ -79,6 +79,7 @@
             const ParameterMap* getParameters() const;
             const String getParameter(const String& parameter_name_) const;
             void setParameter(const String& parameter_name_, const String& parameter_value_);
+            void updateParameter(const String& parameter_name_, const String& parameter_value_);
             
             // Get the pointer to properties
             const PropertyMap* getProperties() const;
@@ -169,11 +170,10 @@
             virtual void useModel(const String& event_name_);
             virtual void useModel();
 
-        private:
+        public:
             // Private copy constructor. Use clone to perform copy operation.
             Model(const Model& model_);
 
-        private:
             // Name of this instance
             String m_instance_name_;
             // Set if this model is the top model
diff -Nur dsent0.91/model/electrical/MatrixArbiter.cc ../dsent0.91/model/electrical/MatrixArbiter.cc
--- dsent0.91/model/electrical/MatrixArbiter.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/electrical/MatrixArbiter.cc	2015-04-24 20:18:56.000000000 -0400
@@ -134,10 +134,10 @@
             {
                 for(unsigned int j = i + 1; j < number_requests; ++j)
                 {
-                    w_or2_names[state_count] = String::format("W_OR2_%d_%d", i, j);
-                    w_and2_names[state_count] = String::format("W_AND2_%d_%d", i, j);
-                    w_inv_names[state_count] = String::format("W_INV_%d_%d", i, j);
-                    w_dff_names[state_count] = String::format("W_DFF_%d_%d", i, j);
+                    w_or2_names[state_count] = String::format("W_OR2_%d_%d", 0, i, j);
+                    w_and2_names[state_count] = String::format("W_AND2_%d_%d", 0, i, j);
+                    w_inv_names[state_count] = String::format("W_INV_%d_%d", 0, i, j);
+                    w_dff_names[state_count] = String::format("W_DFF_%d_%d", 0, i, j);
                     w_or2s[state_count] = getTechModel()->getStdCellLib()->createStdCell("OR2", w_or2_names[state_count]);
                     w_or2s[state_count]->construct();
                     w_and2s[state_count] = getTechModel()->getStdCellLib()->createStdCell("AND2", w_and2_names[state_count]);
@@ -147,9 +147,9 @@
                     w_dffs[state_count] = getTechModel()->getStdCellLib()->createStdCell("DFFQ", w_dff_names[state_count]);
                     w_dffs[state_count]->construct();
 
-                    dis_inv_names[state_count] = String::format("Dis_INV_%d_%d", i, j);
-                    dis_and2_names[state_count] = String::format("Dis_AND2_%d_%d", i, j);
-                    dis_and2_names[state_count + number_states] = String::format("Dis_AND2_%d_%d", j, i);
+                    dis_inv_names[state_count] = String::format("Dis_INV_%d_%d", 0,i, j);
+                    dis_and2_names[state_count] = String::format("Dis_AND2_%d_%d", 0, i, j);
+                    dis_and2_names[state_count + number_states] = String::format("Dis_AND2_%d_%d", 0, j, i);
                     dis_invs[state_count] = getTechModel()->getStdCellLib()->createStdCell("INV", dis_inv_names[state_count]);
                     dis_invs[state_count]->construct();
                     dis_and2s[state_count] = getTechModel()->getStdCellLib()->createStdCell("AND2", dis_and2_names[state_count]);
@@ -184,34 +184,34 @@
 
                 for(unsigned int j = i + 1; j < number_requests; ++j)
                 {
-                    createNet(String::format("W_INV_Out_%d_%d", i, j));
-                    createNet(String::format("W_OR2_Out_%d_%d", i, j));
-                    createNet(String::format("W_AND2_Out_%d_%d", i, j));
-                    createNet(String::format("W_DFF_Out_%d_%d", i, j));
+                    createNet(String::format("W_INV_Out_%d_%d", 0, i, j));
+                    createNet(String::format("W_OR2_Out_%d_%d", 0, i, j));
+                    createNet(String::format("W_AND2_Out_%d_%d", 0, i, j));
+                    createNet(String::format("W_DFF_Out_%d_%d", 0, i, j));
                     portConnect(w_invs[state_count], "A", "Grant" + (String)i);
-                    portConnect(w_invs[state_count], "Y", String::format("W_INV_Out_%d_%d", i, j));
-                    portConnect(w_or2s[state_count], "A", String::format("W_DFF_Out_%d_%d", i, j));
+                    portConnect(w_invs[state_count], "Y", String::format("W_INV_Out_%d_%d", 0, i, j));
+                    portConnect(w_or2s[state_count], "A", String::format("W_DFF_Out_%d_%d", 0, i, j));
                     portConnect(w_or2s[state_count], "B", "Grant" + (String)j);
-                    portConnect(w_or2s[state_count], "Y", String::format("W_OR2_Out_%d_%d", i, j));
-                    portConnect(w_and2s[state_count], "A", String::format("W_OR2_Out_%d_%d", i, j));
-                    portConnect(w_and2s[state_count], "B", String::format("W_INV_Out_%d_%d", i, j));
-                    portConnect(w_and2s[state_count], "Y", String::format("W_AND2_Out_%d_%d", i, j));
-                    portConnect(w_dffs[state_count], "D", String::format("W_AND2_Out_%d_%d", i, j));
+                    portConnect(w_or2s[state_count], "Y", String::format("W_OR2_Out_%d_%d", 0, i, j));
+                    portConnect(w_and2s[state_count], "A", String::format("W_OR2_Out_%d_%d", 0, i, j));
+                    portConnect(w_and2s[state_count], "B", String::format("W_INV_Out_%d_%d", 0, i, j));
+                    portConnect(w_and2s[state_count], "Y", String::format("W_AND2_Out_%d_%d", 0, i, j));
+                    portConnect(w_dffs[state_count], "D", String::format("W_AND2_Out_%d_%d", 0, i, j));
                     portConnect(w_dffs[state_count], "CK", "CK");
-                    portConnect(w_dffs[state_count], "Q", String::format("W_DFF_Out_%d_%d", i, j));
+                    portConnect(w_dffs[state_count], "Q", String::format("W_DFF_Out_%d_%d", 0, i, j));
 
-                    createNet(String::format("Dis_AND2_Out_%d_%d", i, j));
-                    createNet(String::format("Dis_AND2_Out_%d_%d", j, i));
-                    createNet(String::format("Dis_INV_Out_%d_%d", j, i));
+                    createNet(String::format("Dis_AND2_Out_%d_%d", 0,i, j));
+                    createNet(String::format("Dis_AND2_Out_%d_%d", 0, j, i));
+                    createNet(String::format("Dis_INV_Out_%d_%d", 0, j, i));
                     portConnect(dis_and2s[state_count], "A", "Request" + (String)i);
-                    portConnect(dis_and2s[state_count], "B", String::format("W_DFF_Out_%d_%d", i, j));
-                    portConnect(dis_and2s[state_count], "Y", String::format("Dis_AND2_Out_%d_%d", i, j));
+                    portConnect(dis_and2s[state_count], "B", String::format("W_DFF_Out_%d_%d", 0, i, j));
+                    portConnect(dis_and2s[state_count], "Y", String::format("Dis_AND2_Out_%d_%d", 0, i, j));
 
-                    portConnect(dis_invs[state_count], "A", String::format("W_DFF_Out_%d_%d", i, j));
-                    portConnect(dis_invs[state_count], "Y", String::format("Dis_INV_Out_%d_%d", j, i));
+                    portConnect(dis_invs[state_count], "A", String::format("W_DFF_Out_%d_%d", 0, i, j));
+                    portConnect(dis_invs[state_count], "Y", String::format("Dis_INV_Out_%d_%d", 0, j, i));
                     portConnect(dis_and2s[state_count + number_states], "A", "Request" + (String)j);
-                    portConnect(dis_and2s[state_count + number_states], "B", String::format("Dis_INV_Out_%d_%d", j, i));
-                    portConnect(dis_and2s[state_count + number_states], "Y", String::format("Dis_AND2_Out_%d_%d", j, i));
+                    portConnect(dis_and2s[state_count + number_states], "B", String::format("Dis_INV_Out_%d_%d", 0, j, i));
+                    portConnect(dis_and2s[state_count + number_states], "Y", String::format("Dis_AND2_Out_%d_%d", 0, j, i));
 
                     state_count++;
                 }
@@ -223,7 +223,7 @@
                 {
                     if(i != j)
                     {
-                        portConnect(dis_ors[i], "In" + (String)k, String::format("Dis_AND2_Out_%d_%d", j, i));
+                        portConnect(dis_ors[i], "In" + (String)k, String::format("Dis_AND2_Out_%d_%d", 0, j, i));
                         k++;
                     }
                 }
@@ -319,13 +319,13 @@
             {
                 for(unsigned int j = i + 1; j < number_requests; ++j)
                 {
-                    w_invs[state_count] = (ElectricalModel*)getSubInstance(String::format("W_INV_%d_%d", i, j));
-                    w_or2s[state_count] = (ElectricalModel*)getSubInstance(String::format("W_OR2_%d_%d", i, j));
-                    w_and2s[state_count] = (ElectricalModel*)getSubInstance(String::format("W_AND2_%d_%d", i, j));
-                    w_dffs[state_count] = (ElectricalModel*)getSubInstance(String::format("W_DFF_%d_%d", i, j));
-                    dis_invs[state_count] = (ElectricalModel*)getSubInstance(String::format("Dis_INV_%d_%d", i, j));
-                    dis_and2s[i * number_requests + j] = (ElectricalModel*)getSubInstance(String::format("Dis_AND2_%d_%d", i, j));
-                    dis_and2s[j * number_requests + i] = (ElectricalModel*)getSubInstance(String::format("Dis_AND2_%d_%d", j, i));
+                    w_invs[state_count] = (ElectricalModel*)getSubInstance(String::format("W_INV_%d_%d", 0, i, j));
+                    w_or2s[state_count] = (ElectricalModel*)getSubInstance(String::format("W_OR2_%d_%d", 0, i, j));
+                    w_and2s[state_count] = (ElectricalModel*)getSubInstance(String::format("W_AND2_%d_%d", 0, i, j));
+                    w_dffs[state_count] = (ElectricalModel*)getSubInstance(String::format("W_DFF_%d_%d", 0, i, j));
+                    dis_invs[state_count] = (ElectricalModel*)getSubInstance(String::format("Dis_INV_%d_%d", 0, i, j));
+                    dis_and2s[i * number_requests + j] = (ElectricalModel*)getSubInstance(String::format("Dis_AND2_%d_%d", 0, i, j));
+                    dis_and2s[j * number_requests + i] = (ElectricalModel*)getSubInstance(String::format("Dis_AND2_%d_%d", 0, j, i));
 
                     w_dffs[state_count]->getInputPort("D")->setTransitionInfo(TransitionInfo(0.5, 0.0, 0.5));
                     propagatePortTransitionInfo(w_dffs[state_count], "CK", "CK");
diff -Nur dsent0.91/model/electrical/Multiplexer.cc ../dsent0.91/model/electrical/Multiplexer.cc
--- dsent0.91/model/electrical/Multiplexer.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/electrical/Multiplexer.cc	2015-04-24 20:18:56.000000000 -0400
@@ -118,8 +118,8 @@
                 {
                     for(unsigned int i = 0; i < number_selects; ++i)
                     {
-                        StdCell* selinv0 = getTechModel()->getStdCellLib()->createStdCell("INV", String::format("Sel%dInv0", i));
-                        StdCell* selinv1 = getTechModel()->getStdCellLib()->createStdCell("INV", String::format("Sel%dInv1", i));
+                        StdCell* selinv0 = getTechModel()->getStdCellLib()->createStdCell("INV", String::format("Sel%dInv0", 0, i));
+                        StdCell* selinv1 = getTechModel()->getStdCellLib()->createStdCell("INV", String::format("Sel%dInv1", 0, i));
                         selinv0->construct();
                         selinv1->construct();
 
@@ -127,8 +127,8 @@
                         addElectricalSubResults(selinv0, 1.0);
                         addSubInstances(selinv1, 1.0);
                         addElectricalSubResults(selinv1, 1.0);
-                        getEventResult("Mux")->addSubResult(selinv0->getEventResult("INV"), String::format("Sel%dInv0", i), 1.0);                
-                        getEventResult("Mux")->addSubResult(selinv1->getEventResult("INV"), String::format("Sel%dInv1", i), 1.0);                
+                        getEventResult("Mux")->addSubResult(selinv0->getEventResult("INV"), String::format("Sel%dInv0", 0, i), 1.0);                
+                        getEventResult("Mux")->addSubResult(selinv1->getEventResult("INV"), String::format("Sel%dInv1", 0, i), 1.0);                
                     }
                 }
 
@@ -146,8 +146,8 @@
                 {
                     for(unsigned int i = 0; i < number_selects; ++i)
                     {
-                        ElectricalModel* selinv0 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv0", i));
-                        ElectricalModel* selinv1 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv1", i));
+                        ElectricalModel* selinv0 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv0", 0, i));
+                        ElectricalModel* selinv1 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv1", 0, i));
                         createNet("SelInv" + (String)i);
                         createNet("SelBuf" + (String)i);
                         portConnect(selinv0, "A", "Sel" + (String)i);
@@ -306,8 +306,8 @@
                 {
                     for(unsigned int i = 0; i < number_selects; ++i)
                     {
-                        ElectricalModel* selinv0 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv0", i));
-                        ElectricalModel* selinv1 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv1", i));
+                        ElectricalModel* selinv0 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv0", 0, i));
+                        ElectricalModel* selinv1 = (ElectricalModel*)getSubInstance(String::format("Sel%dInv1", 0, i));
                         propagatePortTransitionInfo(selinv0, "A", "Sel" + (String)i);
                         selinv0->use();
                         propagatePortTransitionInfo(selinv1, "A", selinv0, "Y");
diff -Nur dsent0.91/model/electrical/MultiplexerCrossbar.cc ../dsent0.91/model/electrical/MultiplexerCrossbar.cc
--- dsent0.91/model/electrical/MultiplexerCrossbar.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/electrical/MultiplexerCrossbar.cc	2015-04-24 20:18:56.000000000 -0400
@@ -70,7 +70,7 @@
         {
             for(unsigned int j = 0; j < number_selects; ++j)
             {
-                createInputPort(String::format("Sel%d_%d", i, j));
+                createInputPort(String::format("Sel%d_%d", 0, i, j));
             }
         }
         // Create output ports
@@ -100,7 +100,7 @@
             {
                 for(unsigned int k = 0; k < number_selects; ++k)
                 {
-                    event_info->setStaticTransitionInfo(String::format("Sel%d_%d", j, k));
+                    event_info->setStaticTransitionInfo(String::format("Sel%d_%d", 0, j, k));
                 }
             }
         }
@@ -131,7 +131,7 @@
             // Connect select signals
             for(unsigned int j = 0; j < number_selects; ++j)
             {
-                portConnect(muxs[i], "Sel" + (String)j, String::format("Sel%d_%d", i, j));
+                portConnect(muxs[i], "Sel" + (String)j, String::format("Sel%d_%d", 0, i, j));
             }
 
             // Connect outputs
@@ -199,7 +199,7 @@
             }
             for(unsigned int j = 0; j < number_selects; ++j)
             {
-                propagatePortTransitionInfo(muxi, "Sel" + (String)j, String::format("Sel%d_%d", i, j));
+                propagatePortTransitionInfo(muxi, "Sel" + (String)j, String::format("Sel%d_%d", 0, i, j));
             }
             muxi->use();
 
diff -Nur dsent0.91/model/electrical/router/Router.cc ../dsent0.91/model/electrical/router/Router.cc
--- dsent0.91/model/electrical/router/Router.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/electrical/router/Router.cc	2015-04-24 20:18:56.000000000 -0400
@@ -398,7 +398,7 @@
         {
             for(unsigned int j = 0; j < number_crossbar_selects; ++j)
             {
-                createNet(String::format("Crossbar_Sel%d_%d", i, j));
+                createNet(String::format("Crossbar_Sel%d_%d", 0, i, j));
             }
             createNet("Crossbar_Out" + (String)i, makeNetIndex(0, number_bits_per_flit-1));
         }
@@ -421,8 +421,8 @@
         {
             for(unsigned int j = 0; j < number_crossbar_selects; ++j)
             {
-                assignVirtualFanout(String::format("Crossbar_Sel%d_%d", i, j), "Crossbar_Sel_DFF_Out");
-                portConnect(crossbar, String::format("Sel%d_%d", i, j), String::format("Crossbar_Sel%d_%d", i, j));
+                assignVirtualFanout(String::format("Crossbar_Sel%d_%d", 0, i, j), "Crossbar_Sel_DFF_Out");
+                portConnect(crossbar, String::format("Sel%d_%d", 0, i, j), String::format("Crossbar_Sel%d_%d", 0, i, j));
             }
             portConnect(crossbar, "Out" + (String)i, "Crossbar_Out" + (String)i);
             assignVirtualFanin("PipelineReg2_In" + (String)i, "Crossbar_Out" + (String)i);
diff -Nur dsent0.91/model/electrical/router/RouterSwitchAllocator.cc ../dsent0.91/model/electrical/router/RouterSwitchAllocator.cc
--- dsent0.91/model/electrical/router/RouterSwitchAllocator.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/model/electrical/router/RouterSwitchAllocator.cc	2015-04-24 20:18:56.000000000 -0400
@@ -68,16 +68,16 @@
         {
             for(unsigned int j = 0; j < stage1_number_requests; ++j)
             {
-                createInputPort(String::format("Stage1Arb%d->Request%d", i, j));
-                createInputPort(String::format("Stage1Arb%d->Grant%d", i, j));
+                createInputPort(String::format("Stage1Arb%d->Request%d", 0, i, j));
+                createInputPort(String::format("Stage1Arb%d->Grant%d", 0, i, j));
             }
         }
         for(unsigned int i = 0; i < number_stage2_arbiters; ++i)
         {
             for(unsigned int j = 0; j < stage2_number_requests; ++j)
             {
-                createInputPort(String::format("Stage2Arb%d->Request%d", i, j));
-                createInputPort(String::format("Stage2Arb%d->Grant%d", i, j));
+                createInputPort(String::format("Stage2Arb%d->Request%d", 0, i, j));
+                createInputPort(String::format("Stage2Arb%d->Grant%d", 0, i, j));
             }
         }
 
@@ -135,8 +135,8 @@
             portConnect(stage1_arb, "Grant" + (String)i, grant_name);
             for(unsigned int j = 0; j < number_stage1_arbiters; ++j)
             {
-                assignVirtualFanin(dff_in_name, String::format("Stage1Arb%d->Request%d", j, i));
-                assignVirtualFanout(String::format("Stage1Arb%d->Grant%d", j, i), grant_name);
+                assignVirtualFanin(dff_in_name, String::format("Stage1Arb%d->Request%d", 0, j, i));
+                assignVirtualFanout(String::format("Stage1Arb%d->Grant%d", 0, j, i), grant_name);
             }
         }
         for(unsigned int i = 0; i < stage2_number_requests; ++i)
@@ -154,8 +154,8 @@
             portConnect(stage2_arb, "Grant" + (String)i, grant_name);
             for(unsigned int j = 0; j < number_stage2_arbiters; ++j)
             {
-                assignVirtualFanin(dff_in_name, String::format("Stage2Arb%d->Request%d", j, i));
-                assignVirtualFanout(String::format("Stage2Arb%d->Grant%d", j, i), grant_name);
+                assignVirtualFanin(dff_in_name, String::format("Stage2Arb%d->Request%d", 0, j, i));
+                assignVirtualFanout(String::format("Stage2Arb%d->Grant%d", 0, j, i), grant_name);
             }
         }
 
diff -Nur dsent0.91/tech/TechModel.h ../dsent0.91/tech/TechModel.h
--- dsent0.91/tech/TechModel.h	2012-05-13 16:14:39.000000000 -0400
+++ ../dsent0.91/tech/TechModel.h	2015-04-24 20:18:56.000000000 -0400
@@ -4,8 +4,8 @@
 #include <vector>
 #include <set>
 
-#include "libutil/Config.h"
-#include "libutil/String.h"
+#include "libutil/libutilConfig.h"
+#include "libutil/libutilString.h"
 
 namespace DSENT
 {
@@ -55,11 +55,9 @@
             // Return wire resistance for given wire layer, wire width, and wire length
             double calculateWireResistance(const String& layer_name_, double width_, double length_) const;
 
-        private:
             // Private copy constructor. Use clone to perform copy operation
             TechModel(const TechModel& tech_model_);
 
-        private:
             // A pointer to a standard cell library
             const StdCellLib* m_std_cell_lib_;
             // A set of available wire layers
diff -Nur dsent0.91/util/Config.cc ../dsent0.91/util/Config.cc
--- dsent0.91/util/Config.cc	2012-05-13 16:14:39.000000000 -0400
+++ ../dsent0.91/util/Config.cc	2015-04-24 20:18:56.000000000 -0400
@@ -5,22 +5,22 @@
 namespace DSENT
 {
 
-    Config* Config::ms_singleton_ = NULL;
+    DSENTConfig* DSENTConfig::ms_singleton_ = NULL;
 
-    void Config::allocate(const String& cfg_file_name_)
+    void DSENTConfig::allocate(const String& cfg_file_name_)
     {
         Log::printLine("Config::allocate");
 
         // Allocate static Config instance
         ASSERT(!ms_singleton_, "Config singleton is allocated");
-        ms_singleton_ = new Config();
+        ms_singleton_ = new DSENTConfig();
         ms_singleton_->readFile(cfg_file_name_);
 
         Log::printLine("Config::allocate - End");
         return;
     }
 
-    void Config::release()
+    void DSENTConfig::release()
     {
         Log::printLine("Config::release");
 
@@ -33,22 +33,22 @@
         return;
     }
 
-    Config* Config::getSingleton()
+    DSENTConfig* DSENTConfig::getSingleton()
     {
         ASSERT(ms_singleton_, "Config singleton is not allocated");
         return ms_singleton_;
     }
 
-    Config::Config()
+    DSENTConfig::DSENTConfig()
         : m_tech_model_(NULL)
     {}
 
-    Config::~Config()
+    DSENTConfig::~DSENTConfig()
     {
         delete m_tech_model_;
     }
 
-    void Config::setTechModel(const TechModel* tech_model_)
+    void DSENTConfig::setTechModel(const TechModel* tech_model_)
     {
         ASSERT((tech_model_ != NULL), "tech_model_ is null");
 
@@ -56,14 +56,14 @@
         return;
     }
 
-    const TechModel* Config::getTechModel() const
+    const TechModel* DSENTConfig::getTechModel() const
     {
         ASSERT((m_tech_model_ != NULL), "m_tech_model_ is null");
 
         return m_tech_model_;
     }
 
-    void Config::readFile(const String& file_name_)
+    void DSENTConfig::readFile(const String& file_name_)
     {
         Log::printLine("Config::readFile");
 
@@ -73,7 +73,7 @@
         return;
     }
 
-    void Config::constructTechModel(const String& overwrite_str_)
+    void DSENTConfig::constructTechModel(const String& overwrite_str_)
     {
         Log::printLine("Config::constructTechModel");
 
diff -Nur dsent0.91/util/Config.h ../dsent0.91/util/Config.h
--- dsent0.91/util/Config.h	2012-05-13 16:14:39.000000000 -0400
+++ ../dsent0.91/util/Config.h	2015-04-24 20:18:56.000000000 -0400
@@ -8,19 +8,21 @@
     class TechModel;
     class StdCellLib;
 
-    class Config : public LibUtil::Config
+    class DSENTConfig : public LibUtil::Config
     {
         public:
             static void allocate(const String& cfg_file_name_);
             static void release();
-            static Config* getSingleton();
+            static DSENTConfig* getSingleton();
+        
+            const TechModel* m_tech_model_;
 
         protected:
-            static Config* ms_singleton_;
+            static DSENTConfig* ms_singleton_;
 
         public:
-            Config();
-            ~Config();
+            DSENTConfig();
+            ~DSENTConfig();
 
         public:
             void setTechModel(const TechModel* tech_model_);
@@ -30,10 +32,7 @@
 
         protected:
             void readFile(const String& file_name_);
-
-        protected:
-            const TechModel* m_tech_model_;
-    }; // class Config
+    }; // class DSENTConfig
 } // namespace DSENT
 
 #endif // __DSENT_UTIL_CONFIG_H__
diff -Nur dsent0.91/util/Result.cc ../dsent0.91/util/Result.cc
--- dsent0.91/util/Result.cc	2012-05-21 23:03:03.000000000 -0400
+++ ../dsent0.91/util/Result.cc	2015-04-24 20:18:56.000000000 -0400
@@ -2,8 +2,8 @@
 
 #include <iostream>
 
-#include "libutil/Log.h"
-#include "libutil/Assert.h"
+#include "libutil/libutilLog.h"
+#include "libutil/libutilAssert.h"
 
 namespace DSENT
 {
diff -Nur dsent0.91/util/Result.h ../dsent0.91/util/Result.h
--- dsent0.91/util/Result.h	2012-05-20 22:40:36.000000000 -0400
+++ ../dsent0.91/util/Result.h	2015-04-24 20:18:56.000000000 -0400
@@ -4,8 +4,8 @@
 #include <iostream>
 #include <vector>
 
-#include "libutil/String.h"
-#include "libutil/Map.h"
+#include "libutil/libutilString.h"
+#include "libutil/libutilMap.h"
 
 namespace DSENT
 {
